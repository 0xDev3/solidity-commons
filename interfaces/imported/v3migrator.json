{
  "schema": "../schema.json",
  "tags": [],
  "name": "V3Migrator",
  "description": "",
  "eventDecorators": [],
  "functionDecorators": [
    {
      "signature": "WETH9()",
      "name": "WETH9",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "createAndInitializePoolIfNecessary(address,address,uint24,uint160)",
      "name": "createAndInitializePoolIfNecessary",
      "description": "Creates a new pool if it does not exist, then initializes if not initialized. This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool.",
      "parameterDecorators": [
        {
          "name": "token0",
          "description": "The contract address of token0 of the pool.",
          "recommendedTypes": []
        },
        {
          "name": "token1",
          "description": "The contract address of token1 of the pool.",
          "recommendedTypes": []
        },
        {
          "name": "fee",
          "description": "The fee amount of the v3 pool for the specified token pair.",
          "recommendedTypes": []
        },
        {
          "name": "sqrtPriceX96",
          "description": "The initial square root price of the pool as a Q64.96 value.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "pool",
          "description": "Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary.",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "factory()",
      "name": "factory",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "migrate(tuple(address,uint256,uint8,address,address,uint24,int24,int24,uint256,uint256,address,uint256,bool))",
      "name": "migrate",
      "description": "Migrates liquidity to v3 by burning v2 liquidity and minting a new position for v3. Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of the maximum amount of v3 liquidity that the v2 liquidity can get. For the special case of migrating to an out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range.",
      "parameterDecorators": [
        {
          "name": "params",
          "description": "The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "pair",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "liquidityToMigrate",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "percentageToMigrate",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "token0",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "token1",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "fee",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "tickLower",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "tickUpper",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amount0Min",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amount1Min",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "recipient",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "deadline",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "refundAsETH",
              "description": "",
              "recommendedTypes": []
            }
          ]
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "multicall(bytes[])",
      "name": "multicall",
      "description": "Call multiple functions in the current contract and return the data from all of them if they all succeed. The `msg.value` should not be trusted for any method callable from multicall.",
      "parameterDecorators": [
        {
          "name": "data",
          "description": "The encoded function data for each of the calls to make to this contract.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "results",
          "description": "The results from each of the calls passed in via data.",
          "recommendedTypes": [],
          "solidityType": "bytes[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)",
      "name": "selfPermit",
      "description": "Permits this contract to spend a given token from `msg.sender`. The `owner` is always msg.sender and the `spender` is always address(this).",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The address of the token spent.",
          "recommendedTypes": []
        },
        {
          "name": "value",
          "description": "The amount that can be spent of token.",
          "recommendedTypes": []
        },
        {
          "name": "deadline",
          "description": "A timestamp, the current blocktime must be less than or equal to this timestamp.",
          "recommendedTypes": []
        },
        {
          "name": "v",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "r",
          "description": "Must produce valid secp256k1 signature from the holder along with `v` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "s",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `v`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)",
      "name": "selfPermitAllowed",
      "description": "Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter. The `owner` is always msg.sender and the `spender` is always address(this).",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The address of the token spent.",
          "recommendedTypes": []
        },
        {
          "name": "nonce",
          "description": "The current nonce of the owner.",
          "recommendedTypes": []
        },
        {
          "name": "expiry",
          "description": "The timestamp at which the permit is no longer valid.",
          "recommendedTypes": []
        },
        {
          "name": "v",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "r",
          "description": "Must produce valid secp256k1 signature from the holder along with `v` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "s",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `v`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)",
      "name": "selfPermitAllowedIfNecessary",
      "description": "Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter. The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The address of the token spent.",
          "recommendedTypes": []
        },
        {
          "name": "nonce",
          "description": "The current nonce of the owner.",
          "recommendedTypes": []
        },
        {
          "name": "expiry",
          "description": "The timestamp at which the permit is no longer valid.",
          "recommendedTypes": []
        },
        {
          "name": "v",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "r",
          "description": "Must produce valid secp256k1 signature from the holder along with `v` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "s",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `v`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)",
      "name": "selfPermitIfNecessary",
      "description": "Permits this contract to spend a given token from `msg.sender`. The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The address of the token spent.",
          "recommendedTypes": []
        },
        {
          "name": "value",
          "description": "The amount that can be spent of token.",
          "recommendedTypes": []
        },
        {
          "name": "deadline",
          "description": "A timestamp, the current blocktime must be less than or equal to this timestamp.",
          "recommendedTypes": []
        },
        {
          "name": "v",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "r",
          "description": "Must produce valid secp256k1 signature from the holder along with `v` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "s",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `v`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "summaSwapV3Manager()",
      "name": "summaSwapV3Manager",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    }
  ]
}