{
  "schema": "../schema.json",
  "tags": [
    "tokens",
    "borrowing",
    "strategies",
    "compound"
  ],
  "name": "FlexibleLeverageStrategyAdapter",
  "description": "FlexibleLeverageStrategyAdapter.",
  "eventDecorators": [
    {
      "signature": "AnyoneCallableUpdated(bool)",
      "name": "AnyoneCallableUpdated",
      "description": "Emitted when a new WPC speed is calculated for a market.",
      "parameterDecorators": [
        {
          "name": "_status",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        }
      ]
    },
    {
      "signature": "CallerStatusUpdated(address,bool)",
      "name": "CallerStatusUpdated",
      "description": "Emitted when a new WPC speed is calculated for a market.",
      "parameterDecorators": [
        {
          "name": "_caller",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "_status",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "Disengaged(uint256,uint256,uint256,uint256)",
      "name": "Disengaged",
      "description": "Emitted when a new WPC speed is calculated for a market.",
      "parameterDecorators": [
        {
          "name": "_currentLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_newLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_chunkRebalanceNotional",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_totalRebalanceNotional",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "Engaged(uint256,uint256,uint256,uint256)",
      "name": "Engaged",
      "description": "Emitted when a new WPC speed is calculated for a market.",
      "parameterDecorators": [
        {
          "name": "_currentLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_newLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_chunkRebalanceNotional",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_totalRebalanceNotional",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "ExecutionSettingsUpdated(uint256,uint256,uint256,uint256,string,bytes)",
      "name": "ExecutionSettingsUpdated",
      "description": "Emitted when a new WPC speed is calculated for a market.",
      "parameterDecorators": [
        {
          "name": "_unutilizedLeveragePercentage",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_twapMaxTradeSize",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_twapCooldownPeriod",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_slippageTolerance",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_exchangeName",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_exchangeData",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "IncentiveSettingsUpdated(uint256,uint256,uint256,uint256,uint256)",
      "name": "IncentiveSettingsUpdated",
      "description": "Emitted when a new WPC speed is calculated for a market.",
      "parameterDecorators": [
        {
          "name": "_etherReward",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_incentivizedLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_incentivizedSlippageTolerance",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_incentivizedTwapCooldownPeriod",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_incentivizedTwapMaxTradeSize",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "MethodologySettingsUpdated(uint256,uint256,uint256,uint256,uint256)",
      "name": "MethodologySettingsUpdated",
      "description": "Emitted when a new WPC speed is calculated for a market.",
      "parameterDecorators": [
        {
          "name": "_targetLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_minLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_maxLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_recenteringSpeed",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_rebalanceInterval",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "RebalanceIterated(uint256,uint256,uint256,uint256)",
      "name": "RebalanceIterated",
      "description": "Emitted when a new WPC speed is calculated for a market.",
      "parameterDecorators": [
        {
          "name": "_currentLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_newLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_chunkRebalanceNotional",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_totalRebalanceNotional",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "Rebalanced(uint256,uint256,uint256,uint256)",
      "name": "Rebalanced",
      "description": "Emitted when a new WPC speed is calculated for a market.",
      "parameterDecorators": [
        {
          "name": "_currentLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_newLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_chunkRebalanceNotional",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_totalRebalanceNotional",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "RipcordCalled(uint256,uint256,uint256,uint256)",
      "name": "RipcordCalled",
      "description": "Emitted when a new WPC speed is calculated for a market.",
      "parameterDecorators": [
        {
          "name": "_currentLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_newLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_rebalanceNotional",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "_etherIncentive",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    }
  ],
  "functionDecorators": [
    {
      "signature": "anyoneCallable()",
      "name": "anyoneCallable",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "callAllowList(address)",
      "name": "callAllowList",
      "description": "",
      "parameterDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "disengage()",
      "name": "disengage",
      "description": "OPERATOR ONLY: Return leverage ratio to 1x and delever to repay loan. This can be used for upgrading or shutting down the strategy. SetToken will redeem collateral position and trade for debt position to repay Compound. If target leverage ratio is above max borrow or max trade size, then operator must continue to call this function to complete repayment of loan. The function iterateRebalance will not work Note: due to slippage tolerance on trades, loan value may not be entirely repaid.",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "engage()",
      "name": "engage",
      "description": "OPERATOR ONLY: Engage to target leverage ratio for the first time. SetToken will borrow debt position from Compound and trade for collateral asset. If target leverage ratio is above max borrow or max trade size, then TWAP is kicked off. To complete engage if TWAP, any valid caller must call iterateRebalance until target is met.",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "execution()",
      "name": "execution",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "unutilizedLeveragePercentage",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "twapMaxTradeSize",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "twapCooldownPeriod",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "slippageTolerance",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "exchangeName",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "string"
        },
        {
          "name": "exchangeData",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getCurrentEtherIncentive()",
      "name": "getCurrentEtherIncentive",
      "description": "Get current Ether incentive for when current leverage ratio exceeds incentivized leverage ratio and ripcord can be called. If ETH balance on the contract is below the etherReward, then return the balance of ETH instead. return etherReward Quantity of ETH reward in base units (10e18).",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getCurrentLeverageRatio()",
      "name": "getCurrentLeverageRatio",
      "description": "Get current leverage ratio. Current leverage ratio is defined as the USD value of the collateral divided by the USD value of the SetToken. Prices for collateral and borrow asset are retrieved from the Compound Price Oracle. return currentLeverageRatio Current leverage ratio in precise units (10e18).",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "gulp()",
      "name": "gulp",
      "description": "ONLY EOA: Call gulp on the CompoundLeverageModule. Gulp will claim COMP from liquidity mining and sell for more collateral asset, which effectively distributes to SetToken holders and reduces the interest rate paid for borrowing. Rebalance must not be in progress. Anyone callable.",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "incentive()",
      "name": "incentive",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "etherReward",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "incentivizedLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "incentivizedSlippageTolerance",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "incentivizedTwapCooldownPeriod",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "incentivizedTwapMaxTradeSize",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "iterateRebalance()",
      "name": "iterateRebalance",
      "description": "ONLY EOA AND ALLOWED CALLER: Iterate a rebalance when in TWAP. TWAP cooldown period must have elapsed. If price moves advantageously, then exit without rebalancing and clear TWAP state. This function can only be called when below incentivized leverage ratio and in TWAP state.",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "lastTradeTimestamp()",
      "name": "lastTradeTimestamp",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "manager()",
      "name": "manager",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "methodology()",
      "name": "methodology",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "targetLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "minLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "maxLeverageRatio",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "recenteringSpeed",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        },
        {
          "name": "rebalanceInterval",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "rebalance()",
      "name": "rebalance",
      "description": "ONLY EOA AND ALLOWED CALLER: Rebalance according to flexible leverage methodology. If current leverage ratio is between the max and min bounds, then rebalance can only be called once the rebalance interval has elapsed since last timestamp. If outside the max and min, rebalance can be called anytime to bring leverage ratio back to the max or min bounds. The methodology will determine whether to delever or lever. Note: If the calculated current leverage ratio is above the incentivized leverage ratio or in TWAP then rebalance cannot be called. Instead, you must call ripcord() which is incentivized with a reward in Ether or iterateRebalance().",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "ripcord()",
      "name": "ripcord",
      "description": "ONLY EOA: In case the current leverage ratio exceeds the incentivized leverage threshold, the ripcord function can be called by anyone to return leverage ratio back to the max leverage ratio. This function typically would only be called during times of high downside volatility and / or normal keeper malfunctions. The caller of ripcord() will receive a reward in Ether. The ripcord function uses it's own TWAP cooldown period, slippage tolerance and TWAP max trade size which are typically looser than in regular rebalances.",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "setExecutionSettings(tuple(uint256,uint256,uint256,uint256,string,bytes))",
      "name": "setExecutionSettings",
      "description": "OPERATOR ONLY: Set execution settings and check new settings are valid. Note: Need to pass in existing parameters if only changing a few settings. Must not be in a rebalance.",
      "parameterDecorators": [
        {
          "name": "_newExecutionSettings",
          "description": "Struct containing execution parameters.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "unutilizedLeveragePercentage",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "twapMaxTradeSize",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "twapCooldownPeriod",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "slippageTolerance",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "exchangeName",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "exchangeData",
              "description": "",
              "recommendedTypes": []
            }
          ]
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "setIncentiveSettings(tuple(uint256,uint256,uint256,uint256,uint256))",
      "name": "setIncentiveSettings",
      "description": "OPERATOR ONLY: Set incentive settings and check new settings are valid. Note: Need to pass in existing parameters if only changing a few settings. Must not be in a rebalance.",
      "parameterDecorators": [
        {
          "name": "_newIncentiveSettings",
          "description": "Struct containing incentive parameters.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "etherReward",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "incentivizedLeverageRatio",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "incentivizedSlippageTolerance",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "incentivizedTwapCooldownPeriod",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "incentivizedTwapMaxTradeSize",
              "description": "",
              "recommendedTypes": []
            }
          ]
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "setMethodologySettings(tuple(uint256,uint256,uint256,uint256,uint256))",
      "name": "setMethodologySettings",
      "description": "OPERATOR ONLY: Set methodology settings and check new settings are valid. Note: Need to pass in existing parameters if only changing a few settings. Must not be in a rebalance.",
      "parameterDecorators": [
        {
          "name": "_newMethodologySettings",
          "description": "Struct containing methodology parameters.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "targetLeverageRatio",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "minLeverageRatio",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "maxLeverageRatio",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "recenteringSpeed",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "rebalanceInterval",
              "description": "",
              "recommendedTypes": []
            }
          ]
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "shouldRebalance()",
      "name": "shouldRebalance",
      "description": "Helper that checks if conditions are met for rebalance or ripcord. Returns an enum with 0 = no rebalance, 1 = call rebalance(), 2 = call iterateRebalance() 3 = call ripcord() return ShouldRebalance Enum detailing whether to rebalance, iterateRebalance, ripcord or no action.",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint8"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "shouldRebalanceWithBounds(uint256,uint256)",
      "name": "shouldRebalanceWithBounds",
      "description": "Helper that checks if conditions are met for rebalance or ripcord with custom max and min bounds specified by caller. This function simplifies the logic for off-chain keeper bots to determine what threshold to call rebalance when leverage exceeds max or drops below min. Returns an enum with 0 = no rebalance, 1 = call rebalance(), 2 = call iterateRebalance()3 = call ripcord().",
      "parameterDecorators": [
        {
          "name": "_customMinLeverageRatio",
          "description": "Min leverage ratio passed in by caller.",
          "recommendedTypes": []
        },
        {
          "name": "_customMaxLeverageRatio",
          "description": "Max leverage ratio passed in by caller return ShouldRebalance Enum detailing whether to rebalance, iterateRebalance, ripcord or no action.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint8"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "strategy()",
      "name": "strategy",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "setToken",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        },
        {
          "name": "leverageModule",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        },
        {
          "name": "comptroller",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        },
        {
          "name": "priceOracle",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        },
        {
          "name": "targetCollateralCToken",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        },
        {
          "name": "targetBorrowCToken",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        },
        {
          "name": "collateralAsset",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        },
        {
          "name": "borrowAsset",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "twapLeverageRatio()",
      "name": "twapLeverageRatio",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "updateAnyoneCallable(bool)",
      "name": "updateAnyoneCallable",
      "description": "OPERATOR ONLY: Toggle whether anyone can call function, bypassing the callAllowlist.",
      "parameterDecorators": [
        {
          "name": "_status",
          "description": "Boolean indicating whether to allow anyone call.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "updateCallerStatus(address[],bool[])",
      "name": "updateCallerStatus",
      "description": "OPERATOR ONLY: Toggle ability for passed addresses to call only allowed caller functions.",
      "parameterDecorators": [
        {
          "name": "_callers",
          "description": "Array of caller addresses to toggle status.",
          "recommendedTypes": []
        },
        {
          "name": "_statuses",
          "description": "Array of statuses for each caller.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "withdrawEtherBalance()",
      "name": "withdrawEtherBalance",
      "description": "OPERATOR ONLY: Withdraw entire balance of ETH in this contract to operator. Rebalance must not be in progress.",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    }
  ]
}