{
  "schema": "../schema.json",
  "tags": [
    "swaps",
    "uniswap"
  ],
  "name": "SwapRouter02",
  "description": "Uniswap V2 and V3 Swap Router.",
  "eventDecorators": [
    {
      "signature": "Approve(address,address)",
      "name": "Approve",
      "description": "",
      "parameterDecorators": [
        {
          "name": "from",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "token",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "OwnershipTransferred(address,address)",
      "name": "OwnershipTransferred",
      "description": "",
      "parameterDecorators": [
        {
          "name": "previousOwner",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "newOwner",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        }
      ]
    }
  ],
  "functionDecorators": [
    {
      "signature": "WETH9()",
      "name": "WETH9",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "approveMax(address)",
      "name": "approveMax",
      "description": "Approves a token for the maximum possible amount.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The token to approve.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "approveMaxMinusOne(address)",
      "name": "approveMaxMinusOne",
      "description": "Approves a token for the maximum possible amount minus one.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The token to approve.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "approveZeroThenMax(address)",
      "name": "approveZeroThenMax",
      "description": "Approves a token for zero, then the maximum possible amount.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The token to approve.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "approveZeroThenMaxMinusOne(address)",
      "name": "approveZeroThenMaxMinusOne",
      "description": "Approves a token for zero, then the maximum possible amount minus one.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The token to approve.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "callPositionManager(bytes)",
      "name": "callPositionManager",
      "description": "Calls the position manager with arbitrary calldata.",
      "parameterDecorators": [
        {
          "name": "data",
          "description": "Calldata to pass along to the position manager.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "result",
          "description": "The result from the call.",
          "recommendedTypes": [],
          "solidityType": "bytes"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "checkOracleSlippage(bytes[],uint128[],uint24,uint32)",
      "name": "checkOracleSlippage",
      "description": "Ensures that the weighted average current (synthetic) tick over the path is no worse than `maximumTickDivergence` ticks away from the average as of `secondsAgo`.",
      "parameterDecorators": [
        {
          "name": "paths",
          "description": "The paths to fetch prices over.",
          "recommendedTypes": []
        },
        {
          "name": "amounts",
          "description": "The weights for each entry in `paths`.",
          "recommendedTypes": []
        },
        {
          "name": "maximumTickDivergence",
          "description": "The maximum number of ticks that the price can degrade by.",
          "recommendedTypes": []
        },
        {
          "name": "secondsAgo",
          "description": "The number of seconds ago to compute oracle prices against.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "checkOracleSlippage(bytes,uint24,uint32)",
      "name": "checkOracleSlippage",
      "description": "Ensures that the current (synthetic) tick over the path is no worse than `maximumTickDivergence` ticks away from the average as of `secondsAgo`.",
      "parameterDecorators": [
        {
          "name": "path",
          "description": "The path to fetch prices over.",
          "recommendedTypes": []
        },
        {
          "name": "maximumTickDivergence",
          "description": "The maximum number of ticks that the price can degrade by.",
          "recommendedTypes": []
        },
        {
          "name": "secondsAgo",
          "description": "The number of seconds ago to compute oracle prices against.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "exactInput(tuple(bytes,address,uint256,uint256))",
      "name": "exactInput",
      "description": "Swaps `amountIn` of one token for as much as possible of another along the specified path. Setting `amountIn` to 0 will cause the contract to look up its own balance, and swap the entire amount, enabling contracts to send tokens before calling this function.",
      "parameterDecorators": [
        {
          "name": "params",
          "description": "The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "path",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "recipient",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amountIn",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amountOutMinimum",
              "description": "",
              "recommendedTypes": []
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "amountOut",
          "description": "The amount of the received token.",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "exactInputSingle(tuple(address,address,uint24,address,uint256,uint256,uint160))",
      "name": "exactInputSingle",
      "description": "Swaps `amountIn` of one token for as much as possible of another token. Setting `amountIn` to 0 will cause the contract to look up its own balance, and swap the entire amount, enabling contracts to send tokens before calling this function.",
      "parameterDecorators": [
        {
          "name": "params",
          "description": "The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "tokenIn",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "tokenOut",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "fee",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "recipient",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amountIn",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amountOutMinimum",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "sqrtPriceLimitX96",
              "description": "",
              "recommendedTypes": []
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "amountOut",
          "description": "The amount of the received token.",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "exactOutput(tuple(bytes,address,uint256,uint256))",
      "name": "exactOutput",
      "description": "Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed) that may remain in the router after the swap.",
      "parameterDecorators": [
        {
          "name": "params",
          "description": "The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "path",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "recipient",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amountOut",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amountInMaximum",
              "description": "",
              "recommendedTypes": []
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "amountIn",
          "description": "The amount of the input token.",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "exactOutputSingle(tuple(address,address,uint24,address,uint256,uint256,uint160))",
      "name": "exactOutputSingle",
      "description": "Swaps as little as possible of one token for `amountOut` of another token that may remain in the router after the swap.",
      "parameterDecorators": [
        {
          "name": "params",
          "description": "The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "tokenIn",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "tokenOut",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "fee",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "recipient",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amountOut",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amountInMaximum",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "sqrtPriceLimitX96",
              "description": "",
              "recommendedTypes": []
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "amountIn",
          "description": "The amount of the input token.",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "factory()",
      "name": "factory",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "factoryV2()",
      "name": "factoryV2",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getApprovalType(address,uint256)",
      "name": "getApprovalType",
      "description": "Lens to be called off-chain to determine which (if any) of the relevant approval functions should be called.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The token to approve.",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "The amount to approve.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "The required approval type.",
          "recommendedTypes": [],
          "solidityType": "uint8"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "increaseLiquidity(tuple(address,address,uint256,uint256,uint256))",
      "name": "increaseLiquidity",
      "description": "Calls the position manager's increaseLiquidity function.",
      "parameterDecorators": [
        {
          "name": "params",
          "description": "Calldata to pass along to the position manager.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "token0",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "token1",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "tokenId",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amount0Min",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amount1Min",
              "description": "",
              "recommendedTypes": []
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "result",
          "description": "The result from the call.",
          "recommendedTypes": [],
          "solidityType": "bytes"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "mint(tuple(address,address,uint24,int24,int24,uint256,uint256,address))",
      "name": "mint",
      "description": "Calls the position manager's mint function.",
      "parameterDecorators": [
        {
          "name": "params",
          "description": "Calldata to pass along to the position manager.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "token0",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "token1",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "fee",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "tickLower",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "tickUpper",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amount0Min",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "amount1Min",
              "description": "",
              "recommendedTypes": []
            },
            {
              "name": "recipient",
              "description": "",
              "recommendedTypes": []
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "result",
          "description": "The result from the call.",
          "recommendedTypes": [],
          "solidityType": "bytes"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "multicall(bytes32,bytes[])",
      "name": "multicall",
      "description": "Call multiple functions in the current contract and return the data from all of them if they all succeed. The `msg.value` should not be trusted for any method callable from multicall.",
      "parameterDecorators": [
        {
          "name": "previousBlockhash",
          "description": "The expected parent blockHash.",
          "recommendedTypes": []
        },
        {
          "name": "data",
          "description": "The encoded function data for each of the calls to make to this contract.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "The results from each of the calls passed in via data.",
          "recommendedTypes": [],
          "solidityType": "bytes[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "multicall(uint256,bytes[])",
      "name": "multicall",
      "description": "Call multiple functions in the current contract and return the data from all of them if they all succeed. The `msg.value` should not be trusted for any method callable from multicall.",
      "parameterDecorators": [
        {
          "name": "deadline",
          "description": "The time by which this function must be called before failing.",
          "recommendedTypes": []
        },
        {
          "name": "data",
          "description": "The encoded function data for each of the calls to make to this contract.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "The results from each of the calls passed in via data.",
          "recommendedTypes": [],
          "solidityType": "bytes[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "multicall(bytes[])",
      "name": "multicall",
      "description": "Call multiple functions in the current contract and return the data from all of them if they all succeed. The `msg.value` should not be trusted for any method callable from multicall.",
      "parameterDecorators": [
        {
          "name": "data",
          "description": "The encoded function data for each of the calls to make to this contract.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "results",
          "description": "The results from each of the calls passed in via data.",
          "recommendedTypes": [],
          "solidityType": "bytes[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "owner()",
      "name": "owner",
      "description": "Returns the address of the current owner.",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "positionManager()",
      "name": "positionManager",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "pull(address,uint256)",
      "name": "pull",
      "description": "Transfers the specified amount of a token from the msg.sender to address(this).",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The token to pull.",
          "recommendedTypes": []
        },
        {
          "name": "value",
          "description": "The amount to pay.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "refundETH()",
      "name": "refundETH",
      "description": "Refunds any ETH balance held by this contract to the `msg.sender`. Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount.",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "renounceOwnership()",
      "name": "renounceOwnership",
      "description": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)",
      "name": "selfPermit",
      "description": "Permits this contract to spend a given token from `msg.sender`. The `owner` is always msg.sender and the `spender` is always address(this).",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The address of the token spent.",
          "recommendedTypes": []
        },
        {
          "name": "value",
          "description": "The amount that can be spent of token.",
          "recommendedTypes": []
        },
        {
          "name": "deadline",
          "description": "A timestamp, the current blocktime must be less than or equal to this timestamp.",
          "recommendedTypes": []
        },
        {
          "name": "v",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "r",
          "description": "Must produce valid secp256k1 signature from the holder along with `v` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "s",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `v`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)",
      "name": "selfPermitAllowed",
      "description": "Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter. The `owner` is always msg.sender and the `spender` is always address(this).",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The address of the token spent.",
          "recommendedTypes": []
        },
        {
          "name": "nonce",
          "description": "The current nonce of the owner.",
          "recommendedTypes": []
        },
        {
          "name": "expiry",
          "description": "The timestamp at which the permit is no longer valid.",
          "recommendedTypes": []
        },
        {
          "name": "v",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "r",
          "description": "Must produce valid secp256k1 signature from the holder along with `v` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "s",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `v`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)",
      "name": "selfPermitAllowedIfNecessary",
      "description": "Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter. The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The address of the token spent.",
          "recommendedTypes": []
        },
        {
          "name": "nonce",
          "description": "The current nonce of the owner.",
          "recommendedTypes": []
        },
        {
          "name": "expiry",
          "description": "The timestamp at which the permit is no longer valid.",
          "recommendedTypes": []
        },
        {
          "name": "v",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "r",
          "description": "Must produce valid secp256k1 signature from the holder along with `v` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "s",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `v`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)",
      "name": "selfPermitIfNecessary",
      "description": "Permits this contract to spend a given token from `msg.sender`. The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The address of the token spent.",
          "recommendedTypes": []
        },
        {
          "name": "value",
          "description": "The amount that can be spent of token.",
          "recommendedTypes": []
        },
        {
          "name": "deadline",
          "description": "A timestamp, the current blocktime must be less than or equal to this timestamp.",
          "recommendedTypes": []
        },
        {
          "name": "v",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "r",
          "description": "Must produce valid secp256k1 signature from the holder along with `v` and `s`.",
          "recommendedTypes": []
        },
        {
          "name": "s",
          "description": "Must produce valid secp256k1 signature from the holder along with `r` and `v`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "swapExactTokensForTokens(uint256,uint256,address[],address)",
      "name": "swapExactTokensForTokens",
      "description": "Swaps `amountIn` of one token for as much as possible of another token. Setting `amountIn` to 0 will cause the contract to look up its own balance, and swap the entire amount, enabling contracts to send tokens before calling this function.",
      "parameterDecorators": [
        {
          "name": "amountIn",
          "description": "The amount of token to swap.",
          "recommendedTypes": []
        },
        {
          "name": "amountOutMin",
          "description": "The minimum amount of output that must be received.",
          "recommendedTypes": []
        },
        {
          "name": "path",
          "description": "The ordered list of tokens to swap through.",
          "recommendedTypes": []
        },
        {
          "name": "to",
          "description": "The recipient address.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "amountOut",
          "description": "The amount of the received token.",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "swapTokensForExactTokens(uint256,uint256,address[],address)",
      "name": "swapTokensForExactTokens",
      "description": "Swaps as little as possible of one token for an exact amount of another token.",
      "parameterDecorators": [
        {
          "name": "amountOut",
          "description": "The amount of token to swap for.",
          "recommendedTypes": []
        },
        {
          "name": "amountInMax",
          "description": "The maximum amount of input that the caller will pay.",
          "recommendedTypes": []
        },
        {
          "name": "path",
          "description": "The ordered list of tokens to swap through.",
          "recommendedTypes": []
        },
        {
          "name": "to",
          "description": "The recipient address.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "amountIn",
          "description": "The amount of token to pay.",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "sweepToken(address,uint256,address)",
      "name": "sweepToken",
      "description": "Transfers the full amount of a token held by this contract to recipient. The amountMinimum parameter prevents malicious contracts from stealing the token from users.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The contract address of the token which will be transferred to `recipient`.",
          "recommendedTypes": []
        },
        {
          "name": "amountMinimum",
          "description": "The minimum amount of token required for a transfer.",
          "recommendedTypes": []
        },
        {
          "name": "recipient",
          "description": "The destination address of the token.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "sweepToken(address,uint256)",
      "name": "sweepToken",
      "description": "Transfers the full amount of a token held by this contract to msg.sender. The amountMinimum parameter prevents malicious contracts from stealing the token from users.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "The contract address of the token which will be transferred to msg.sender.",
          "recommendedTypes": []
        },
        {
          "name": "amountMinimum",
          "description": "The minimum amount of token required for a transfer.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "sweepTokenWithFee(address,uint256,uint256,address)",
      "name": "sweepTokenWithFee",
      "description": "Transfers the full amount of a token held by this contract to msg.sender, with a percentage between 0 (exclusive) and 1 (inclusive) going to feeRecipient. The amountMinimum parameter prevents malicious contracts from stealing the token from users.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "amountMinimum",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "feeBips",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "feeRecipient",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "sweepTokenWithFee(address,uint256,address,uint256,address)",
      "name": "sweepTokenWithFee",
      "description": "Transfers the full amount of a token held by this contract to recipient, with a percentage between 0 (exclusive) and 1 (inclusive) going to feeRecipient. The amountMinimum parameter prevents malicious contracts from stealing the token from users.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "amountMinimum",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "recipient",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "feeBips",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "feeRecipient",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "transferOwnership(address)",
      "name": "transferOwnership",
      "description": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.",
      "parameterDecorators": [
        {
          "name": "newOwner",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "transferToken(address,address)",
      "name": "transferToken",
      "description": "Transfer tokens from contract.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "for transfer.",
          "recommendedTypes": []
        },
        {
          "name": "from",
          "description": "recipient.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "result { true } if transferred.",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "transferToken(address,address,uint256)",
      "name": "transferToken",
      "description": "Transfer tokens from contract.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "for transfer.",
          "recommendedTypes": []
        },
        {
          "name": "from",
          "description": "recipient.",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "of transfer.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "result { true } if transferred.",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "uniswapV3SwapCallback(int256,int256,bytes)",
      "name": "uniswapV3SwapCallback",
      "description": "Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap. In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.",
      "parameterDecorators": [
        {
          "name": "amount0Delta",
          "description": "The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.",
          "recommendedTypes": []
        },
        {
          "name": "amount1Delta",
          "description": "The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.",
          "recommendedTypes": []
        },
        {
          "name": "data",
          "description": "Any data passed through by the caller via the IUniswapV3PoolActions#swap call.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "unwrapWETH9(uint256,address)",
      "name": "unwrapWETH9",
      "description": "Unwraps the contract's WETH9 balance and sends it to recipient as ETH. The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",
      "parameterDecorators": [
        {
          "name": "amountMinimum",
          "description": "The minimum amount of WETH9 to unwrap.",
          "recommendedTypes": []
        },
        {
          "name": "recipient",
          "description": "The address receiving ETH.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "unwrapWETH9(uint256)",
      "name": "unwrapWETH9",
      "description": "Unwraps the contract's WETH9 balance and sends it to msg.sender as ETH. The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",
      "parameterDecorators": [
        {
          "name": "amountMinimum",
          "description": "The minimum amount of WETH9 to unwrap.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "unwrapWETH9WithFee(uint256,address,uint256,address)",
      "name": "unwrapWETH9WithFee",
      "description": "Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between 0 (exclusive), and 1 (inclusive) going to feeRecipient. The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",
      "parameterDecorators": [
        {
          "name": "amountMinimum",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "recipient",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "feeBips",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "feeRecipient",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "unwrapWETH9WithFee(uint256,uint256,address)",
      "name": "unwrapWETH9WithFee",
      "description": "Unwraps the contract's WETH9 balance and sends it to msg.sender as ETH, with a percentage between 0 (exclusive), and 1 (inclusive) going to feeRecipient. The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",
      "parameterDecorators": [
        {
          "name": "amountMinimum",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "feeBips",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "feeRecipient",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "wrapETH(uint256)",
      "name": "wrapETH",
      "description": "Wraps the contract's ETH balance into WETH9. The resulting WETH9 is custodied by the router, thus will require further distribution.",
      "parameterDecorators": [
        {
          "name": "value",
          "description": "The amount of ETH to wrap.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    }
  ]
}