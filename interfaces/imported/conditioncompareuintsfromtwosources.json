{
  "schema": "../schema.json",
  "tags": [],
  "name": "ConditionCompareUintsFromTwoSources",
  "description": "This contract only works if the refContracts fns returndata has a uint in the first 32-byte position. A general contract for retrieving and comparing 2 uints from 2 contracts.",
  "eventDecorators": [],
  "functionDecorators": [
    {
      "signature": "compare(address,address,bytes,bytes,uint256)",
      "name": "compare",
      "description": "Compares 2 values from sourceA and sourceB to check if minSpread is there. If you want to trigger when ContractA uint is greater than or equal to ContractB by _minSpread: (ContractA=_sourceA, ContractB=_sourceB) For the reverse (lower than/equal to): (ContractA=_sourceB, ContractB=_sourceA).",
      "parameterDecorators": [
        {
          "name": "_sourceA",
          "description": "The first contract that returns a uint for comparison.",
          "recommendedTypes": []
        },
        {
          "name": "_sourceB",
          "description": "The second contract that returns a uint256 for comparison.",
          "recommendedTypes": []
        },
        {
          "name": "_sourceAData",
          "description": "Payload for retrieving the uint from _sourceA.",
          "recommendedTypes": []
        },
        {
          "name": "_sourceBData",
          "description": "Payload for retrieving the uint from _sourceB.",
          "recommendedTypes": []
        },
        {
          "name": "_minSpread",
          "description": "The minimum diff between sourceA and sourceB for the Condition to be relevant.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "OK if the Condition is fulfilled.",
          "recommendedTypes": [],
          "solidityType": "string"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getConditionData(address,address,bytes,bytes,uint256)",
      "name": "getConditionData",
      "description": "Helper to encode the Condition.data field off-chain.",
      "parameterDecorators": [
        {
          "name": "_sourceA",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "_sourceB",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "_sourceAData",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "_sourceBData",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "_minSpread",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "ok(uint256,bytes,uint256)",
      "name": "ok",
      "description": "Gelato Standard Condition function. Every Gelato Condition must have this function selector as entry point.",
      "parameterDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "_conditionData",
          "description": "The encoded data from getConditionData().",
          "recommendedTypes": []
        },
        {
          "name": "param1",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "string"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    }
  ]
}