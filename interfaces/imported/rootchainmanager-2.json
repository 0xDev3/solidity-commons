{"schema":"../schema.json","tags":[],"name":"RootChainManager","description":"","eventDecorators":[{"signature":"MetaTransactionExecuted(address,address,bytes)","name":"MetaTransactionExecuted","description":"events for transfer. Emitted when maximum value of ETH is raised.","parameterDecorators":[{"name":"userAddress","description":"","recommendedTypes":[],"indexed":false},{"name":"relayerAddress","description":"","recommendedTypes":[],"indexed":false},{"name":"functionSignature","description":"","recommendedTypes":[],"indexed":false}]},{"signature":"PredicateRegistered(bytes32,address)","name":"PredicateRegistered","description":"events for transfer. Emitted when maximum value of ETH is raised.","parameterDecorators":[{"name":"tokenType","description":"","recommendedTypes":[],"indexed":true},{"name":"predicateAddress","description":"","recommendedTypes":[],"indexed":true}]},{"signature":"RoleAdminChanged(bytes32,bytes32,bytes32)","name":"RoleAdminChanged","description":"events for transfer. Emitted when maximum value of ETH is raised.","parameterDecorators":[{"name":"role","description":"","recommendedTypes":[],"indexed":true},{"name":"previousAdminRole","description":"","recommendedTypes":[],"indexed":true},{"name":"newAdminRole","description":"","recommendedTypes":[],"indexed":true}]},{"signature":"RoleGranted(bytes32,address,address)","name":"RoleGranted","description":"events for transfer. Emitted when maximum value of ETH is raised.","parameterDecorators":[{"name":"role","description":"","recommendedTypes":[],"indexed":true},{"name":"account","description":"","recommendedTypes":[],"indexed":true},{"name":"sender","description":"","recommendedTypes":[],"indexed":true}]},{"signature":"RoleRevoked(bytes32,address,address)","name":"RoleRevoked","description":"events for transfer. Emitted when maximum value of ETH is raised.","parameterDecorators":[{"name":"role","description":"","recommendedTypes":[],"indexed":true},{"name":"account","description":"","recommendedTypes":[],"indexed":true},{"name":"sender","description":"","recommendedTypes":[],"indexed":true}]},{"signature":"TokenMapped(address,address,bytes32)","name":"TokenMapped","description":"events for transfer. Emitted when maximum value of ETH is raised.","parameterDecorators":[{"name":"rootToken","description":"","recommendedTypes":[],"indexed":true},{"name":"childToken","description":"","recommendedTypes":[],"indexed":true},{"name":"tokenType","description":"","recommendedTypes":[],"indexed":true}]}],"functionDecorators":[{"signature":"DEFAULT_ADMIN_ROLE()","name":"DEFAULT_ADMIN_ROLE","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bytes32"}],"emittableEvents":[],"readOnly":true},{"signature":"DEPOSIT()","name":"DEPOSIT","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bytes32"}],"emittableEvents":[],"readOnly":true},{"signature":"ERC712_VERSION()","name":"ERC712_VERSION","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"string"}],"emittableEvents":[],"readOnly":true},{"signature":"ETHER_ADDRESS()","name":"ETHER_ADDRESS","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"MAPPER_ROLE()","name":"MAPPER_ROLE","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bytes32"}],"emittableEvents":[],"readOnly":true},{"signature":"MAP_TOKEN()","name":"MAP_TOKEN","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bytes32"}],"emittableEvents":[],"readOnly":true},{"signature":"checkpointManagerAddress()","name":"checkpointManagerAddress","description":"Get the address of contract set as checkpoint manager.","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"childChainManagerAddress()","name":"childChainManagerAddress","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"childToRootToken(address)","name":"childToRootToken","description":"","parameterDecorators":[{"name":"param0","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"cleanMapToken(address,address)","name":"cleanMapToken","description":"Clean polluted token mapping.","parameterDecorators":[{"name":"rootToken","description":"address of token on root chain. Since rename token was introduced later stage, clean method is used to clean pollulated mapping.","recommendedTypes":[]},{"name":"childToken","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"depositEtherFor(address)","name":"depositEtherFor","description":"Move ether from root to child chain, accepts ether transfer Keep in mind this ether cannot be used to pay gas on child chain Use Matic tokens deposited using plasma mechanism for that.","parameterDecorators":[{"name":"user","description":"address of account that should receive WETH on child chain.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"depositFor(address,address,bytes)","name":"depositFor","description":"Move tokens from root to child chain. This mechanism supports arbitrary tokens as long as its predicate has been registered and the token is mapped.","parameterDecorators":[{"name":"user","description":"address of account that should receive this deposit on child chain.","recommendedTypes":[]},{"name":"rootToken","description":"address of token that is being deposited.","recommendedTypes":[]},{"name":"depositData","description":"bytes data that is sent to predicate and child token contracts to handle deposit.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)","name":"executeMetaTransaction","description":"","parameterDecorators":[{"name":"userAddress","description":"","recommendedTypes":[]},{"name":"functionSignature","description":"","recommendedTypes":[]},{"name":"sigR","description":"","recommendedTypes":[]},{"name":"sigS","description":"","recommendedTypes":[]},{"name":"sigV","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bytes"}],"emittableEvents":[],"readOnly":false},{"signature":"exit(bytes)","name":"exit","description":"exit tokens by providing proof. This function verifies if the transaction actually happened on child chain the transaction log is then sent to token predicate to handle it accordingly.","parameterDecorators":[{"name":"inputData","description":"RLP encoded data of the reference tx containing following list of fields 0 - headerNumber - Checkpoint header block number containing the reference tx 1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root 2 - blockNumber - Block number containing the reference tx on child chain 3 - blockTime - Reference tx block time 4 - txRoot - Transactions root of block 5 - receiptRoot - Receipts root of block 6 - receipt - Receipt of the reference transaction 7 - receiptProof - Merkle proof of the reference receipt 8 - branchMask - 32 bits denoting the path of receipt in merkle tree 9 - receiptLogIndex - Log Index to read from the receipt.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"getChainId()","name":"getChainId","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"getDomainSeperator()","name":"getDomainSeperator","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bytes32"}],"emittableEvents":[],"readOnly":true},{"signature":"getNonce(address)","name":"getNonce","description":"","parameterDecorators":[{"name":"user","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"nonce","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"getRoleAdmin(bytes32)","name":"getRoleAdmin","description":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. * To change a role's admin, use {_setRoleAdmin}.","parameterDecorators":[{"name":"role","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bytes32"}],"emittableEvents":[],"readOnly":true},{"signature":"getRoleMember(bytes32,uint256)","name":"getRoleMember","description":"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. * Role bearers are not sorted in any particular way, and their ordering may change at any point. * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.","parameterDecorators":[{"name":"role","description":"","recommendedTypes":[]},{"name":"index","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"getRoleMemberCount(bytes32)","name":"getRoleMemberCount","description":"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.","parameterDecorators":[{"name":"role","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"grantRole(bytes32,address)","name":"grantRole","description":"Grants `role` to `account`. * If `account` had not been already granted `role`, emits a {RoleGranted} event. * Requirements: * - the caller must have ``role``'s admin role.","parameterDecorators":[{"name":"role","description":"","recommendedTypes":[]},{"name":"account","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":["RoleGranted(bytes32,address,address)"],"readOnly":false},{"signature":"hasRole(bytes32,address)","name":"hasRole","description":"Returns `true` if `account` has been granted `role`.","parameterDecorators":[{"name":"role","description":"","recommendedTypes":[]},{"name":"account","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bool"}],"emittableEvents":[],"readOnly":true},{"signature":"initialize(address)","name":"initialize","description":"Initialize the contract after it has been proxified. meant to be called once immediately after deployment.","parameterDecorators":[{"name":"_owner","description":"the account that should be granted admin role.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"initializeEIP712()","name":"initializeEIP712","description":"","parameterDecorators":[],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"mapToken(address,address,bytes32)","name":"mapToken","description":"Map a token to enable its movement via the PoS Portal, callable only by mappers.","parameterDecorators":[{"name":"rootToken","description":"address of token on root chain.","recommendedTypes":[]},{"name":"childToken","description":"address of token on child chain.","recommendedTypes":[]},{"name":"tokenType","description":"bytes32 unique identifier for the token type.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"processedExits(bytes32)","name":"processedExits","description":"","parameterDecorators":[{"name":"param0","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bool"}],"emittableEvents":[],"readOnly":true},{"signature":"registerPredicate(bytes32,address)","name":"registerPredicate","description":"Register a token predicate address against its type, callable only by mappers. A predicate is a contract responsible to process the token specific logic while locking or exiting tokens.","parameterDecorators":[{"name":"tokenType","description":"bytes32 unique identifier for the token type.","recommendedTypes":[]},{"name":"predicateAddress","description":"address of token predicate address.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"remapToken(address,address,bytes32)","name":"remapToken","description":"Remap a token that has already been mapped, properly cleans up old mapping Callable only by mappers.","parameterDecorators":[{"name":"rootToken","description":"address of token on root chain.","recommendedTypes":[]},{"name":"childToken","description":"address of token on child chain.","recommendedTypes":[]},{"name":"tokenType","description":"bytes32 unique identifier for the token type.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"renounceRole(bytes32,address)","name":"renounceRole","description":"Revokes `role` from the calling account. * Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). * If the calling account had been granted `role`, emits a {RoleRevoked} event. * Requirements: * - the caller must be `account`.","parameterDecorators":[{"name":"role","description":"","recommendedTypes":[]},{"name":"account","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":["RoleRevoked(bytes32,address,address)"],"readOnly":false},{"signature":"revokeRole(bytes32,address)","name":"revokeRole","description":"Revokes `role` from `account`. * If `account` had been granted `role`, emits a {RoleRevoked} event. * Requirements: * - the caller must have ``role``'s admin role.","parameterDecorators":[{"name":"role","description":"","recommendedTypes":[]},{"name":"account","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":["RoleRevoked(bytes32,address,address)"],"readOnly":false},{"signature":"rootToChildToken(address)","name":"rootToChildToken","description":"","parameterDecorators":[{"name":"param0","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"setCheckpointManager(address)","name":"setCheckpointManager","description":"Set the checkpoint manager, callable only by admins. This should be the plasma contract responsible for keeping track of checkpoints.","parameterDecorators":[{"name":"newCheckpointManager","description":"address of checkpoint manager contract.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setChildChainManagerAddress(address)","name":"setChildChainManagerAddress","description":"Set the child chain manager, callable only by admins. This should be the contract responsible to receive deposit bytes on child chain.","parameterDecorators":[{"name":"newChildChainManager","description":"address of child chain manager contract.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setStateSender(address)","name":"setStateSender","description":"Set the state sender, callable only by admins. This should be the state sender from plasma contracts It is used to send bytes from root to child chain.","parameterDecorators":[{"name":"newStateSender","description":"address of state sender contract.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setupContractId()","name":"setupContractId","description":"","parameterDecorators":[],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"stateSenderAddress()","name":"stateSenderAddress","description":"Get the address of contract set as state sender.","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"tokenToType(address)","name":"tokenToType","description":"","parameterDecorators":[{"name":"param0","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bytes32"}],"emittableEvents":[],"readOnly":true},{"signature":"typeToPredicate(bytes32)","name":"typeToPredicate","description":"","parameterDecorators":[{"name":"param0","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true}]}