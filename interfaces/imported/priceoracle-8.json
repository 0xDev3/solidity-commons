{"schema":"../schema.json","tags":["oracles","tokens","liquidity"],"name":"PriceOracle","description":"PriceOracle. An ////important assumption of the PriceOracle is that settlement dates are aligned to 8am UTC, and separated either by 1 day or 1 week. The value of the dateOffset state variable determines whether the interval between settlement dates is 1 day or 1 week. We do this because we do not want to fragment liquidity and complicate the UX by allowing for arbitrary settlement dates, so we enforce a specific interval between all Series' settlement datesAll prices are normalized to 8 decimal places.","eventDecorators":[{"signature":"CodeAddressUpdated(address)","name":"CodeAddressUpdated","description":"round => id => address *.","parameterDecorators":[{"name":"newAddress","description":"","recommendedTypes":[],"indexed":false}]},{"signature":"OracleSet(address,address,address,uint256)","name":"OracleSet","description":"round => id => address *.","parameterDecorators":[{"name":"amount","description":"amount of tokens purchased.","recommendedTypes":[],"indexed":false},{"name":"beneficiary","description":"who got the tokens.","recommendedTypes":[],"indexed":false},{"name":"purchaser","description":"who paid for the tokens.","recommendedTypes":[],"indexed":false},{"name":"value","description":"weis paid for purchase.","recommendedTypes":[],"indexed":false}]},{"signature":"OwnershipTransferred(address,address)","name":"OwnershipTransferred","description":"round => id => address *.","parameterDecorators":[{"name":"previousOwner","description":"","recommendedTypes":[],"indexed":true},{"name":"newOwner","description":"","recommendedTypes":[],"indexed":true}]},{"signature":"SettlementPriceSet(address,address,uint256,uint256)","name":"SettlementPriceSet","description":"round => id => address *.","parameterDecorators":[{"name":"amount","description":"amount of tokens purchased.","recommendedTypes":[],"indexed":false},{"name":"beneficiary","description":"who got the tokens.","recommendedTypes":[],"indexed":false},{"name":"purchaser","description":"who paid for the tokens.","recommendedTypes":[],"indexed":false},{"name":"value","description":"weis paid for purchase.","recommendedTypes":[],"indexed":false}]}],"functionDecorators":[{"signature":"addTokenPair(address,address,address)","name":"addTokenPair","description":"Sets the price oracle to use for the given underlyingToken and priceToken pair.","parameterDecorators":[{"name":"underlyingToken","description":"Should be equal to the Series' underlyingToken field.","recommendedTypes":[]},{"name":"priceToken","description":"Should be equal to the Series' priceToken field.","recommendedTypes":[]},{"name":"oracle","description":"The address of the price oracle contract.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"get8amWeeklyOrDailyAligned(uint256)","name":"get8amWeeklyOrDailyAligned","description":"Returns the given timestamp date, but aligned to the prior 8am UTC dateOffset in the past unless the timestamp is exactly 8am UTC, in which case it will return the same value as the timestamp. If PriceOracle.dateOffset is 1 day then this function will align on every day at 8am, and if its 1 week it will align on every Friday 8am UTC.","parameterDecorators":[{"name":"_timestamp","description":"a block time (seconds past epoch).","recommendedTypes":[]}],"returnDecorators":[{"name":"_0","description":"the block time of the prior (or current) 8am UTC date, dateOffset in the past.","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"getCurrentPrice(address,address)","name":"getCurrentPrice","description":"Use an oracle keyed by the underlyingToken-priceToken pair to fetch the current price.","parameterDecorators":[{"name":"underlyingToken","description":"Should be equal to the Series' underlyingToken field.","recommendedTypes":[]},{"name":"priceToken","description":"Should be equal to the Series' priceToken field.","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"getLogicAddress()","name":"getLogicAddress","description":"","parameterDecorators":[],"returnDecorators":[{"name":"logicAddress","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"getSettlementPrice(address,address,uint256)","name":"getSettlementPrice","description":"get the settlement price with the given underlyingToken and priceToken, at the given expirationDate, and whether the price exists.","parameterDecorators":[{"name":"underlyingToken","description":"Should be equal to the Series' underlyingToken field.","recommendedTypes":[]},{"name":"priceToken","description":"Should be equal to the Series' priceToken field.","recommendedTypes":[]},{"name":"settlementDate","description":"Should be equal to the expirationDate of the Series we're getting the settlement price for.","recommendedTypes":[]}],"returnDecorators":[{"name":"_0","description":"true if the settlement price has been set (i.e. is nonzero), false otherwise.","recommendedTypes":[],"solidityType":"bool"},{"name":"_1","description":"the settlement price.","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"initialize(uint256)","name":"initialize","description":"Setup the owner and date time and range for this PriceOracle.","parameterDecorators":[{"name":"_dateOffset","description":"the time length in seconds between successive settlement dates. MUST be either 1 day or 1 week. On mainnet networks we always use 1 week, but for testnets in order to have faster testing iterations we reduce the interval to 1 day.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"owner()","name":"owner","description":"Returns the address of the current owner.","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"proxiableUUID()","name":"proxiableUUID","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bytes32"}],"emittableEvents":[],"readOnly":true},{"signature":"renounceOwnership()","name":"renounceOwnership","description":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.","parameterDecorators":[],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setSettlementPrice(address,address)","name":"setSettlementPrice","description":"Stores the current price from the oracle specified by the pair underlyingToken-priceToken. More than a single settlement price may be set, because this function will set all prices for each prior date until it reaches a settlement date that previously had a price set, or it runs out of gasThis function should be called each dateOffset as soon as the block.timestamp passes 8am UTC, so that the current spot price we set is as close to the price at 8am UTC. If we this is called at 8:30am, for instance, and the 8am UTC price hasn't been set yet, then we're going to set a price that is 30 minutes later than intended. This will be more impactful the more volatile prices are.","parameterDecorators":[{"name":"underlyingToken","description":"Should be equal to the Series' underlyingToken field.","recommendedTypes":[]},{"name":"priceToken","description":"Should be equal to the Series' priceToken field.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setSettlementPriceForDate(address,address,uint256)","name":"setSettlementPriceForDate","description":"Stores the current price from the oracle specified by the pair underlyingToken-priceToken for the given settlement date. This function exists only to prevent scenarios where the while loop in PriceOracle.setSettlementPrice consumes too much gas and fails with an Out Of Gas error. Since this function only sets a single date, it is in no danger of running out of gasThis function call will fail if the date is not aligned to 8am UTC, and will be a no-op if a price at the given date has already been set.","parameterDecorators":[{"name":"underlyingToken","description":"Should be equal to the Markets' underlyingToken field.","recommendedTypes":[]},{"name":"priceToken","description":"Should be equal to the Markets' priceToken field.","recommendedTypes":[]},{"name":"date","description":"A date aligned to 8am UTC and offset by dateOffset which the settlement price should be set on.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"transferOwnership(address)","name":"transferOwnership","description":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.","parameterDecorators":[{"name":"newOwner","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"updateImplementation(address)","name":"updateImplementation","description":"update the PriceOracle's logic contract.","parameterDecorators":[{"name":"newPriceOracleImpl","description":"the address of the new price oracle implementation contract.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false}]}