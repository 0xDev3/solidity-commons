{
  "schema": "../schema.json",
  "tags": [
    "tokens",
    "lending",
    "compound"
  ],
  "name": "DharmaSmartWalletImplementationV15Staging",
  "description": "DharmaSmartWalletImplementationV15 (staging version).",
  "eventDecorators": [
    {
      "signature": "CallFailure(bytes32,uint256,address,uint256,bytes,string)",
      "name": "CallFailure",
      "description": "Event for token purchase logging.",
      "parameterDecorators": [
        {
          "name": "actionID",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "nonce",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "to",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "value",
          "description": "weis paid for purchase.",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "data",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "revertReason",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "CallSuccess(bytes32,bool,uint256,address,uint256,bytes,bytes)",
      "name": "CallSuccess",
      "description": "Event for token purchase logging.",
      "parameterDecorators": [
        {
          "name": "actionID",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "rolledBack",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "nonce",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "to",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "value",
          "description": "weis paid for purchase.",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "data",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "returnData",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "Cancel(uint256)",
      "name": "Cancel",
      "description": "Event for token purchase logging.",
      "parameterDecorators": [
        {
          "name": "cancelledNonce",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "Escaped()",
      "name": "Escaped",
      "description": "Event for token purchase logging.",
      "parameterDecorators": []
    },
    {
      "signature": "EthWithdrawal(uint256,address)",
      "name": "EthWithdrawal",
      "description": "Event for token purchase logging.",
      "parameterDecorators": [
        {
          "name": "amount",
          "description": "amount of tokens purchased.",
          "recommendedTypes": [],
          "indexed": false
        },
        {
          "name": "recipient",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "ExternalError(address,string)",
      "name": "ExternalError",
      "description": "Event for token purchase logging.",
      "parameterDecorators": [
        {
          "name": "source",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "revertReason",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "NewUserSigningKey(address)",
      "name": "NewUserSigningKey",
      "description": "Event for token purchase logging.",
      "parameterDecorators": [
        {
          "name": "userSigningKey",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    }
  ],
  "functionDecorators": [
    {
      "signature": "_executeActionWithAtomicBatchCallsAtomic(tuple(address,uint96,bytes)[])",
      "name": "_executeActionWithAtomicBatchCallsAtomic",
      "description": "Protected function that can only be called from `executeActionWithAtomicBatchCalls` on this contract. It will attempt to perform each specified call, populating the array of results as it goes, unless a failure occurs, at which point it will revert and \"return\" the array of results as revert data. Otherwise, it will simply return the array upon successful completion of each call. Finally, note that this function must currently be implemented as a public function (instead of as an external one) due to an ABIEncoderV2 `UnimplementedFeatureError`.",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "Call[] A struct containing the target, value, and calldata to provide when making each call.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "callResults",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "tuple[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "_executeAdvancedActionWithAtomicBatchCallsAtomic(tuple(address,uint96,bytes,tuple,tuple[])[])",
      "name": "_executeAdvancedActionWithAtomicBatchCallsAtomic",
      "description": "",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            },
            {
              "name": "replaceValue",
              "description": "",
              "type": "tuple"
            },
            {
              "name": "replaceData",
              "description": "",
              "type": "tuple[]"
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "callResults",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "tuple[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "_simulateActionWithAtomicBatchCallsAtomic(tuple(address,uint96,bytes)[])",
      "name": "_simulateActionWithAtomicBatchCallsAtomic",
      "description": "Protected function that can only be called from `simulateActionWithAtomicBatchCalls` on this contract. It will attempt to perform each specified call, populating the array of results as it goes, unless a failure occurs, at which point it will revert and \"return\" the array of results as revert data. Regardless, it will roll back all calls at the end of execution â€” in other words, this call always reverts.",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "Call[] A struct containing the target, value, and calldata to provide when making each call.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "callResults",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "tuple[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "_simulateAdvancedActionWithAtomicBatchCallsAtomic(tuple(address,uint96,bytes,tuple,tuple[])[])",
      "name": "_simulateAdvancedActionWithAtomicBatchCallsAtomic",
      "description": "",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            },
            {
              "name": "replaceValue",
              "description": "",
              "type": "tuple"
            },
            {
              "name": "replaceData",
              "description": "",
              "type": "tuple[]"
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "callResults",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "tuple[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "cancel(uint256,bytes)",
      "name": "cancel",
      "description": "Allow a signatory to increment the nonce at any point. The current nonce needs to be provided as an argument to the signature so as not to enable griefing attacks. All arguments can be omitted if called directly. No value is returned from this function - it will either succeed or revert.",
      "parameterDecorators": [
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        },
        {
          "name": "signature",
          "description": "bytes A signature that resolves to either the public key set for this account in storage slot zero, `_userSigningKey`, or the public key returned for this account from the Dharma Key Registry. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the signed message.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "escape(address)",
      "name": "escape",
      "description": "Allow the designated escape hatch account to redeem and \"sweep\" the total token balance or Ether balance (by supplying the null address) from the smart wallet. The call will revert for any other caller, or if there is no escape hatch account on this smart wallet. An `Escaped` event will be emitted. No value is returned from this function - it will either succeed or revert.",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "executeActionWithAtomicBatchCalls(tuple(address,uint96,bytes)[],uint256,bytes,bytes)",
      "name": "executeActionWithAtomicBatchCalls",
      "description": "Perform a series of generic calls to other contracts. If any call fails during execution, the preceding calls will be rolled back, but their original return data will still be accessible. Calls that would otherwise occur after the failed call will not be executed. Note that accounts with no code may not be specified unless value is included, nor may the smart wallet itself or the escape hatch registry. In order to increment the nonce and invalidate the signatures, a call to this function with valid targets, signatutes, and gas will always succeed. To determine whether each call made as part of the action was successful or not, either the corresponding return value or `CallSuccess` and `CallFailure` events can be used - note that even calls that return a success status will be rolled back unless all of the calls returned a success status. Finally, note that this function must currently be implemented as a public function (instead of as an external one) due to an ABIEncoderV2 `UnimplementedFeatureError`.",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "Call[] A struct containing the target, value, and calldata to provide when making each call.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            }
          ]
        },
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        },
        {
          "name": "userSignature",
          "description": "bytes A signature that resolves to the public key set for this account in storage slot zero, `_userSigningKey`. If the user signing key is not a contract, ecrecover will be used; otherwise, ERC1271 will be used. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the message hash for the signature.",
          "recommendedTypes": []
        },
        {
          "name": "dharmaSignature",
          "description": "bytes A signature that resolves to the public key returned for this account from the Dharma Key Registry. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the signed message.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "ok",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bool[]"
        },
        {
          "name": "returnData",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "executeAdvancedActionWithAtomicBatchCalls(tuple(address,uint96,bytes,tuple,tuple[])[],uint256,bytes,bytes)",
      "name": "executeAdvancedActionWithAtomicBatchCalls",
      "description": "",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            },
            {
              "name": "replaceValue",
              "description": "",
              "type": "tuple"
            },
            {
              "name": "replaceData",
              "description": "",
              "type": "tuple[]"
            }
          ]
        },
        {
          "name": "minimumActionGas",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "userSignature",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "dharmaSignature",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "ok",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bool[]"
        },
        {
          "name": "returnData",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "getAdvancedGenericAtomicBatchActionID(tuple(address,uint96,bytes,tuple,tuple[])[],uint256,uint256)",
      "name": "getAdvancedGenericAtomicBatchActionID",
      "description": "",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            },
            {
              "name": "replaceValue",
              "description": "",
              "type": "tuple"
            },
            {
              "name": "replaceData",
              "description": "",
              "type": "tuple[]"
            }
          ]
        },
        {
          "name": "nonce",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "minimumActionGas",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "actionID",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes32"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getCustomActionID(uint8,uint256,address,uint256,uint256)",
      "name": "getCustomActionID",
      "description": "View function that, given an action type and arguments, will return the action ID or message hash that will need to be prefixed (according to EIP-191 0x45), hashed, and signed by both the user signing key and by the key returned for this smart wallet by the Dharma Key Registry in order to construct a valid signature for the corresponding action. The current nonce will be used, which means that it will only be valid for the next action taken.",
      "parameterDecorators": [
        {
          "name": "action",
          "description": "uint8 The type of action, designated by it's index. Valid custom actions include Cancel (0), SetUserSigningKey (1), DAIWithdrawal (10), USDCWithdrawal (5), ETHWithdrawal (6), SetEscapeHatch (7), RemoveEscapeHatch (8), and DisableEscapeHatch (9).",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "uint256 The amount to withdraw for Withdrawal actions. This value is ignored for non-withdrawal action types.",
          "recommendedTypes": []
        },
        {
          "name": "recipient",
          "description": "address The account to transfer withdrawn funds to or the new user signing key. This value is ignored for Cancel, RemoveEscapeHatch, and DisableEscapeHatch action types.",
          "recommendedTypes": []
        },
        {
          "name": "nonce",
          "description": "uint256 The nonce to use.",
          "recommendedTypes": []
        },
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "actionID",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes32"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getGenericAtomicBatchActionID(tuple(address,uint96,bytes)[],uint256,uint256)",
      "name": "getGenericAtomicBatchActionID",
      "description": "View function that, given an action type and arguments, will return the action ID or message hash that will need to be prefixed (according to EIP-191 0x45), hashed, and signed by both the user signing key and by the key returned for this smart wallet by the Dharma Key Registry in order to construct a valid signature for a given generic atomic batch action. Any nonce value may be supplied, which enables constructing valid message hashes for multiple future actions ahead of time. Finally, note that this function must currently be implemented as a public function (instead of as an external one) due to an ABIEncoderV2 `UnimplementedFeatureError`.",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "Call[] A struct containing the target and calldata to provide when making each call.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            }
          ]
        },
        {
          "name": "nonce",
          "description": "uint256 The nonce to use.",
          "recommendedTypes": []
        },
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "actionID",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes32"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getImplementation()",
      "name": "getImplementation",
      "description": "View function for getting the current Dharma Smart Wallet implementation contract address set on the upgrade beacon.",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "implementation",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getNextAdvancedGenericAtomicBatchActionID(tuple(address,uint96,bytes,tuple,tuple[])[],uint256)",
      "name": "getNextAdvancedGenericAtomicBatchActionID",
      "description": "",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            },
            {
              "name": "replaceValue",
              "description": "",
              "type": "tuple"
            },
            {
              "name": "replaceData",
              "description": "",
              "type": "tuple[]"
            }
          ]
        },
        {
          "name": "minimumActionGas",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "actionID",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes32"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getNextCustomActionID(uint8,uint256,address,uint256)",
      "name": "getNextCustomActionID",
      "description": "View function that, given an action type and arguments, will return the action ID or message hash that will need to be prefixed (according to EIP-191 0x45), hashed, and signed by both the user signing key and by the key returned for this smart wallet by the Dharma Key Registry in order to construct a valid signature for the corresponding action. Any nonce value may be supplied, which enables constructing valid message hashes for multiple future actions ahead of time.",
      "parameterDecorators": [
        {
          "name": "action",
          "description": "uint8 The type of action, designated by it's index. Valid custom actions include Cancel (0), SetUserSigningKey (1), DAIWithdrawal (10), USDCWithdrawal (5), ETHWithdrawal (6), SetEscapeHatch (7), RemoveEscapeHatch (8), and DisableEscapeHatch (9).",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "uint256 The amount to withdraw for Withdrawal actions. This value is ignored for non-withdrawal action types.",
          "recommendedTypes": []
        },
        {
          "name": "recipient",
          "description": "address The account to transfer withdrawn funds to or the new user signing key. This value is ignored for Cancel, RemoveEscapeHatch, and DisableEscapeHatch action types.",
          "recommendedTypes": []
        },
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "actionID",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes32"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getNextGenericAtomicBatchActionID(tuple(address,uint96,bytes)[],uint256)",
      "name": "getNextGenericAtomicBatchActionID",
      "description": "View function that, given an action type and arguments, will return the action ID or message hash that will need to be prefixed (according to EIP-191 0x45), hashed, and signed by both the user signing key and by the key returned for this smart wallet by the Dharma Key Registry in order to construct a valid signature for a given generic atomic batch action. The current nonce will be used, which means that it will only be valid for the next action taken. Finally, note that this function must currently be implemented as a public function (instead of as an external one) due to an ABIEncoderV2 `UnimplementedFeatureError`.",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "Call[] A struct containing the target and calldata to provide when making each call.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            }
          ]
        },
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "actionID",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes32"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getNonce()",
      "name": "getNonce",
      "description": "View function for getting the current nonce of the smart wallet. This nonce is incremented whenever an action is taken that requires a signature and/or a specific caller.",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "nonce",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getUserSigningKey()",
      "name": "getUserSigningKey",
      "description": "View function for getting the current user signing key for the smart wallet.",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "userSigningKey",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "address"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getVersion()",
      "name": "getVersion",
      "description": "Pure function for getting the current Dharma Smart Wallet version.",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "version",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "initialize(address)",
      "name": "initialize",
      "description": "In the initializer, set up the initial user signing key. Note that this initializer is only callable while the smart wallet instance is still in the contract creation phase.",
      "parameterDecorators": [
        {
          "name": "userSigningKey",
          "description": "address The initial user signing key for the smart wallet.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "isValidSignature(bytes32,bytes)",
      "name": "isValidSignature",
      "description": "",
      "parameterDecorators": [
        {
          "name": "digest",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "signatures",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "magicValue",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes4"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "isValidSignature(bytes,bytes)",
      "name": "isValidSignature",
      "description": "View function that implements ERC-1271 and validates a set of signatures, one from the owner (using ERC-1271 as well if the user signing key is a contract) and one from the Dharma Key Registry against the supplied data. The data must be ABI encoded as (bytes32, bytes), where the first bytes32 parameter represents the hash digest for validating the supplied signatures and the second bytes parameter contains context for the requested validation. The two signatures are packed together, with the one from Dharma coming first and that from the user coming second - this is so that, in future versions, multiple user signatures may be supplied if the associated key ring requires them.",
      "parameterDecorators": [
        {
          "name": "data",
          "description": "bytes The data used to validate the signature.",
          "recommendedTypes": []
        },
        {
          "name": "signatures",
          "description": "bytes The two signatures, each 65 bytes - one from the owner (using ERC-1271 as well if the user signing key is a contract) and one from the Dharma Key Registry.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "magicValue",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes4"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "permanentlyDisableEscapeHatch(uint256,bytes,bytes)",
      "name": "permanentlyDisableEscapeHatch",
      "description": "Permanently disable the \"escape hatch\" mechanism for this smart wallet. This function call will revert if the smart wallet has already called `permanentlyDisableEscapeHatch` at any point in the past. No value is returned from this function - it will either succeed or revert.",
      "parameterDecorators": [
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        },
        {
          "name": "userSignature",
          "description": "bytes A signature that resolves to the public key set for this account in storage slot zero, `_userSigningKey`. If the user signing key is not a contract, ecrecover will be used; otherwise, ERC1271 will be used. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the message hash for the signature.",
          "recommendedTypes": []
        },
        {
          "name": "dharmaSignature",
          "description": "bytes A signature that resolves to the public key returned for this account from the Dharma Key Registry. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the signed message.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "recover(address)",
      "name": "recover",
      "description": "Allow the account recovery manager to set a new user signing key on the smart wallet. The call will revert for any other caller. The account recovery manager implements a set of controls around the process, including a timelock and an option to permanently opt out of account recover. No value is returned from this function - it will either succeed or revert.",
      "parameterDecorators": [
        {
          "name": "newUserSigningKey",
          "description": "address The new user signing key to set on this smart wallet.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "redeemAllDDai()",
      "name": "redeemAllDDai",
      "description": "Redeem all Dharma Dai held by this account for Dai.",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "redeemAllDUSDC()",
      "name": "redeemAllDUSDC",
      "description": "Redeem all Dharma USD Coin held by this account for USDC.",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "removeEscapeHatch(uint256,bytes,bytes)",
      "name": "removeEscapeHatch",
      "description": "Remove the \"escape hatch\" account if one is currently set. This function call will revert if the smart wallet has previously called `permanentlyDisableEscapeHatch` at any point and disabled the escape hatch. No value is returned from this function - it will either succeed or revert.",
      "parameterDecorators": [
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        },
        {
          "name": "userSignature",
          "description": "bytes A signature that resolves to the public key set for this account in storage slot zero, `_userSigningKey`. If the user signing key is not a contract, ecrecover will be used; otherwise, ERC1271 will be used. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the message hash for the signature.",
          "recommendedTypes": []
        },
        {
          "name": "dharmaSignature",
          "description": "bytes A signature that resolves to the public key returned for this account from the Dharma Key Registry. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the signed message.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "setApproval(address,uint256)",
      "name": "setApproval",
      "description": "",
      "parameterDecorators": [
        {
          "name": "token",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "setEscapeHatch(address,uint256,bytes,bytes)",
      "name": "setEscapeHatch",
      "description": "Set a dedicated address as the \"escape hatch\" account. This account can then call `escape(address token)` at any point to \"sweep\" the entire balance of the token (or Ether given null address) from the smart wallet. The escape hatch account may also call `recover` and set a new user signing key. This function will revert if the smart wallet has previously called `permanentlyDisableEscapeHatch` at any point and disabled the escape hatch. No value is returned from this function - it will either succeed or revert.",
      "parameterDecorators": [
        {
          "name": "account",
          "description": "address The account to set as the escape hatch account.",
          "recommendedTypes": []
        },
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        },
        {
          "name": "userSignature",
          "description": "bytes A signature that resolves to the public key set for this account in storage slot zero, `_userSigningKey`. If the user signing key is not a contract, ecrecover will be used; otherwise, ERC1271 will be used. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the message hash for the signature.",
          "recommendedTypes": []
        },
        {
          "name": "dharmaSignature",
          "description": "bytes A signature that resolves to the public key returned for this account from the Dharma Key Registry. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the signed message.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "setUserSigningKey(address,uint256,bytes,bytes)",
      "name": "setUserSigningKey",
      "description": "Allow signatory to set a new user signing key. The current nonce needs to be provided as an argument to the signature so as not to enable griefing attacks. No value is returned from this function - it will either succeed or revert.",
      "parameterDecorators": [
        {
          "name": "userSigningKey",
          "description": "address The new user signing key to set on this smart wallet.",
          "recommendedTypes": []
        },
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        },
        {
          "name": "userSignature",
          "description": "bytes A signature that resolves to the public key set for this account in storage slot zero, `_userSigningKey`. If the user signing key is not a contract, ecrecover will be used; otherwise, ERC1271 will be used. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the message hash for the signature.",
          "recommendedTypes": []
        },
        {
          "name": "dharmaSignature",
          "description": "bytes A signature that resolves to the public key returned for this account from the Dharma Key Registry. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the signed message.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "simulateActionWithAtomicBatchCalls(tuple(address,uint96,bytes)[])",
      "name": "simulateActionWithAtomicBatchCalls",
      "description": "Simulate a series of generic calls to other contracts. Signatures are not required, but all calls will be rolled back (and calls will only be simulated up until a failing call is encountered).",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "Call[] A struct containing the target, value, and calldata to provide when making each call.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "ok",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bool[]"
        },
        {
          "name": "returnData",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "simulateAdvancedActionWithAtomicBatchCalls(tuple(address,uint96,bytes,tuple,tuple[])[])",
      "name": "simulateAdvancedActionWithAtomicBatchCalls",
      "description": "",
      "parameterDecorators": [
        {
          "name": "calls",
          "description": "",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "to",
              "description": "",
              "type": "address"
            },
            {
              "name": "value",
              "description": "",
              "type": "uint96"
            },
            {
              "name": "data",
              "description": "",
              "type": "bytes"
            },
            {
              "name": "replaceValue",
              "description": "",
              "type": "tuple"
            },
            {
              "name": "replaceData",
              "description": "",
              "type": "tuple[]"
            }
          ]
        }
      ],
      "returnDecorators": [
        {
          "name": "ok",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bool[]"
        },
        {
          "name": "returnData",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bytes[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "triggerEtherTransfer(address,uint256)",
      "name": "triggerEtherTransfer",
      "description": "",
      "parameterDecorators": [
        {
          "name": "target",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "success",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "withdrawEther(uint256,address,uint256,bytes,bytes)",
      "name": "withdrawEther",
      "description": "Withdraw Ether to a provided recipient address by transferring it to a recipient.",
      "parameterDecorators": [
        {
          "name": "amount",
          "description": "uint256 The amount of Ether to withdraw.",
          "recommendedTypes": []
        },
        {
          "name": "recipient",
          "description": "address The account to transfer the Ether to.",
          "recommendedTypes": []
        },
        {
          "name": "minimumActionGas",
          "description": "uint256 The minimum amount of gas that must be provided to this call - be aware that additional gas must still be included to account for the cost of overhead incurred up until the start of this function call.",
          "recommendedTypes": []
        },
        {
          "name": "userSignature",
          "description": "bytes A signature that resolves to the public key set for this account in storage slot zero, `_userSigningKey`. If the user signing key is not a contract, ecrecover will be used; otherwise, ERC1271 will be used. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the message hash for the signature.",
          "recommendedTypes": []
        },
        {
          "name": "dharmaSignature",
          "description": "bytes A signature that resolves to the public key returned for this account from the Dharma Key Registry. A unique hash returned from `getCustomActionID` is prefixed and hashed to create the signed message.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "ok",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": false
    }
  ]
}