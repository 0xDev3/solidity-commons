{"schema":"../schema.json","tags":[],"name":"ExhibitionConsumer","description":"","eventDecorators":[{"signature":"Reserved(address,uint256)","name":"Reserved","description":"","parameterDecorators":[{"name":"user","description":"","recommendedTypes":[],"indexed":true},{"name":"untReserved","description":"","recommendedTypes":[],"indexed":false}]},{"signature":"Withdrawn(address,uint256)","name":"Withdrawn","description":"Must be emitted in withdraw() function.","parameterDecorators":[{"name":"user","description":"","recommendedTypes":[],"indexed":true},{"name":"untEarned","description":"","recommendedTypes":[],"indexed":false}]}],"functionDecorators":[{"signature":"accountDebt(address)","name":"accountDebt","description":"","parameterDecorators":[{"name":"param0","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"accountPrevAmount(address)","name":"accountPrevAmount","description":"","parameterDecorators":[{"name":"param0","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"accountReserved(address)","name":"accountReserved","description":"","parameterDecorators":[{"name":"param0","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"accumulatedUnt()","name":"accumulatedUnt","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"allocate(address,uint256,address)","name":"allocate","description":"Called by the governance to signal an allocation event. The implementation must limit calls to the governance and should give the consumer a chance to handle allocations (like timestamp updates) Returns true if the allocation has been accepted, false if not.","parameterDecorators":[{"name":"_account","description":"","recommendedTypes":[]},{"name":"prevAllocation","description":"","recommendedTypes":[]},{"name":"_peer","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bool"}],"emittableEvents":[],"readOnly":false},{"signature":"allocationDuration()","name":"allocationDuration","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"allocationEnd()","name":"allocationEnd","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"allocationUpdate(address,uint256,uint256,address)","name":"allocationUpdate","description":"Called by the governance upon staking if the allocation for a user and a peer changes. The consumer has then the ability to check what has been changed and act accordingly. Must contain a check if the caller has been the governance.","parameterDecorators":[{"name":"_account","description":"","recommendedTypes":[]},{"name":"prevAmount","description":"","recommendedTypes":[]},{"name":"prevAllocation","description":"","recommendedTypes":[]},{"name":"_peer","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bool"},{"name":"param1","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":false},{"signature":"apInfo(address)","name":"apInfo","description":"_peer parameter to apply the AP info for. Frontend function to help displaying apr/apy and similar strategies. The first index of the returned tuple should return \"r\" if APR or \"y\" if APY. The second index of the returned tuple should return the actual APR/Y value for the consumer. 18 decimals precision required. The 2nd uint256[] array should return a list of proposed services for price discovery on the client-side. 0 = uni-v2 unt/eth 1 = uni-v2 unt/usdt 2 = uni-v2 unt/usdc 3 = uni-v3 unt/eth 4 = uni-v3 unt/usdt 5 = uni-v3 unt/usdc 6 = kucoin unt/usdt 7 = binance unt/usdt The rate and list should be udpatable/extendible through an admin function due to possible updates on the client-side. (e.g. adding more exchanges).","parameterDecorators":[{"name":"_peer","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"string"},{"name":"param1","description":"","recommendedTypes":[],"solidityType":"uint256"},{"name":"param2","description":"","recommendedTypes":[],"solidityType":"uint256[]"}],"emittableEvents":[],"readOnly":true},{"signature":"collectedUnt()","name":"collectedUnt","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"consumerDscription()","name":"consumerDscription","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"string"}],"emittableEvents":[],"readOnly":true},{"signature":"consumerName()","name":"consumerName","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"string"}],"emittableEvents":[],"readOnly":true},{"signature":"continueExhibition()","name":"continueExhibition","description":"","parameterDecorators":[],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"controllerVestingDuration()","name":"controllerVestingDuration","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"dellocate(address,uint256,address)","name":"dellocate","description":"Called by the governance to signal an dellocation event. The implementation must limit calls to the governance and should give the consumer a chance to handle allocations (like timestamp updates).","parameterDecorators":[{"name":"_account","description":"","recommendedTypes":[]},{"name":"prevAllocation","description":"","recommendedTypes":[]},{"name":"_peer","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":false},{"signature":"description()","name":"description","description":"The description for this consumer must be requestable. This information is supposed to be used in clients.","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"string"}],"emittableEvents":[],"readOnly":true},{"signature":"earned(address)","name":"earned","description":"Must return the account's _current_ UNT earnings (as of current blockchain state). Used in the frontend.","parameterDecorators":[{"name":"_account","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"earnedLive(address)","name":"earnedLive","description":"Same as earned() except adding a live component that may be inaccurate due to not yet occurred state-changes. If unsure how to implement, call and return earned() inside. Used in the frontend.","parameterDecorators":[{"name":"_account","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"emergencyRelease(uint256)","name":"emergencyRelease","description":"","parameterDecorators":[{"name":"_amount","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"exhibition()","name":"exhibition","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"exhibitionDuration()","name":"exhibitionDuration","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"exhibitionEnd()","name":"exhibitionEnd","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"exhibitionStart()","name":"exhibitionStart","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"frozen(address)","name":"frozen","description":"Called by the governance to determine if allocated stakes of an account in the governance should stay frozen. If this returns true, the governance won't release NIF upon unstaking.","parameterDecorators":[{"name":"_account","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bool"}],"emittableEvents":[],"readOnly":true},{"signature":"gov()","name":"gov","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"graceTime()","name":"graceTime","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"initialize()","name":"initialize","description":"","parameterDecorators":[],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"initialize(string,string,string,uint256,uint256,uint256,uint256[],uint256,address)","name":"initialize","description":"Consumers must hold a reference to the governance. The constructor is the best place to set it up.","parameterDecorators":[{"name":"_name","description":"","recommendedTypes":[]},{"name":"_description","description":"","recommendedTypes":[]},{"name":"_peerUri","description":"","recommendedTypes":[]},{"name":"_graceTime","description":"","recommendedTypes":[]},{"name":"_untRateStakers","description":"","recommendedTypes":[]},{"name":"_untRateExhibitionController","description":"","recommendedTypes":[]},{"name":"_priceProviders","description":"","recommendedTypes":[]},{"name":"_version","description":"","recommendedTypes":[]},{"name":"_owner","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"isOptionWithdraw(address)","name":"isOptionWithdraw","description":"Should return if the given account is supposed to use optionWithdraw() or not. If it returns true, the account must call optionWithdraw() and pay to receive UNT. If it returns false, the account must call withdraw() to receive earned UNT.","parameterDecorators":[{"name":"_account","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bool"}],"emittableEvents":[],"readOnly":true},{"signature":"lastCollectionBlock()","name":"lastCollectionBlock","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"lastCollectionUpdate()","name":"lastCollectionUpdate","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"name()","name":"name","description":"The name of this consumer must be requestable. This information is supposed to be used in clients.","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"string"}],"emittableEvents":[],"readOnly":true},{"signature":"nifAddress()","name":"nifAddress","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"optionExerciseDuration()","name":"optionExerciseDuration","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"optionWithdraw(uint256)","name":"optionWithdraw","description":"Withdraws UNT solely for exhibition collectors or stakers. Both have the option to get discounted UNT based on the price set in the unt price oracle.","parameterDecorators":[{"name":"_amountUnt","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":false},{"signature":"optionsRelease()","name":"optionsRelease","description":"","parameterDecorators":[],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"owner()","name":"owner","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"paidToController()","name":"paidToController","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"pausing()","name":"pausing","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bool"}],"emittableEvents":[],"readOnly":true},{"signature":"peerNifCap(address)","name":"peerNifCap","description":"If there are any nif caps per peer, this function should return those.","parameterDecorators":[{"name":"_peer","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"peerUri(address)","name":"peerUri","description":"Should return a URI, pointing to a json file in the format: { name : '', description : '', external_link : '', } Can throw an error if the peer is not whitelisted or return an empty string if there is no further information. Since this is supposed to be called by clients, those have to catch errors and handle empty return values themselves.","parameterDecorators":[{"name":"_peer","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"string"}],"emittableEvents":[],"readOnly":true},{"signature":"peerWhitelisted(address)","name":"peerWhitelisted","description":"Returns true if the peer is whitelisted, otherwise false.","parameterDecorators":[{"name":"_peer","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bool"}],"emittableEvents":[],"readOnly":true},{"signature":"priceOracle()","name":"priceOracle","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"priceProviders(uint256)","name":"priceProviders","description":"","parameterDecorators":[{"name":"param0","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"removePeerFromWhitelist(address)","name":"removePeerFromWhitelist","description":"Peer whitelist removal required to be implemented. If no peers should be used, this can have an empty implementation. Example would be to vote for farms in the governance being removed and exluded. Must contain a check if the caller has been the governance.","parameterDecorators":[{"name":"_peer","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setDurations(uint256,uint256,uint256,uint256)","name":"setDurations","description":"","parameterDecorators":[{"name":"_exhibitionDuration","description":"","recommendedTypes":[]},{"name":"_allocationDuration","description":"","recommendedTypes":[]},{"name":"_controllerVestingDuration","description":"","recommendedTypes":[]},{"name":"_optionExerciseDuration","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setGovernance(address)","name":"setGovernance","description":"In case we want to move to a new governance.","parameterDecorators":[{"name":"_gov","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setGraceTime(uint256)","name":"setGraceTime","description":"","parameterDecorators":[{"name":"_graceTime","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setNameAndDescription(string,string)","name":"setNameAndDescription","description":"","parameterDecorators":[{"name":"_name","description":"","recommendedTypes":[]},{"name":"_description","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setPausing(bool,bool)","name":"setPausing","description":"","parameterDecorators":[{"name":"_pausing","description":"","recommendedTypes":[]},{"name":"_withdrawOnPause","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setPeerUri(string)","name":"setPeerUri","description":"","parameterDecorators":[{"name":"_uri","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setPriceOracle(address)","name":"setPriceOracle","description":"","parameterDecorators":[{"name":"_priceOracle","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setPriceProviders(uint256[])","name":"setPriceProviders","description":"","parameterDecorators":[{"name":"_priceProviders","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"setRates(uint256,uint256)","name":"setRates","description":"","parameterDecorators":[{"name":"_untRateStakers","description":"","recommendedTypes":[]},{"name":"_untRateExhibitionController","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"timeToUnfreeze(address)","name":"timeToUnfreeze","description":"Must return the time in seconds that is left until the allocation of a user to the peer he is allocating to expires.","parameterDecorators":[{"name":"_account","description":"","recommendedTypes":[]}],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"transferOwnership(address)","name":"transferOwnership","description":"","parameterDecorators":[{"name":"_newOwner","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"unlocked()","name":"unlocked","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"untAddress()","name":"untAddress","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"untRate()","name":"untRate","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"untRateExhibitionController()","name":"untRateExhibitionController","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"uriPeer()","name":"uriPeer","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"string"}],"emittableEvents":[],"readOnly":true},{"signature":"version()","name":"version","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":true},{"signature":"whitelistPeer(address)","name":"whitelistPeer","description":"Peer whitelist required to be implemented. If no peers should be used, this can have an empty implementation. Example would be to vote for farms in the governance being included. Accepted peers can then be added to the consumer's internal whitelist and get further benefits like UNT. Must contain a check if the caller has been the governance. Must return a string holding the name of the peer (being used for client display).","parameterDecorators":[{"name":"_peer","description":"","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"withdraw()","name":"withdraw","description":"Withdraws UNT solely for artists. No options involved here.","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"uint256"}],"emittableEvents":[],"readOnly":false},{"signature":"withdrawOnPause()","name":"withdrawOnPause","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"bool"}],"emittableEvents":[],"readOnly":true}]}