{"schema":"../schema.json","tags":["swaps","uniswap"],"name":"V3Migrator","description":"Uniswap V3 Migrator.","eventDecorators":[],"functionDecorators":[{"signature":"WETH9()","name":"WETH9","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"createAndInitializePoolIfNecessary(address,address,uint24,uint160)","name":"createAndInitializePoolIfNecessary","description":"Creates a new pool if it does not exist, then initializes if not initialized. This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool.","parameterDecorators":[{"name":"token0","description":"The contract address of token0 of the pool.","recommendedTypes":[]},{"name":"token1","description":"The contract address of token1 of the pool.","recommendedTypes":[]},{"name":"fee","description":"The fee amount of the v3 pool for the specified token pair.","recommendedTypes":[]},{"name":"sqrtPriceX96","description":"The initial square root price of the pool as a Q64.96 value.","recommendedTypes":[]}],"returnDecorators":[{"name":"pool","description":"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary.","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":false},{"signature":"factory()","name":"factory","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"migrate(tuple(address,uint256,uint8,address,address,uint24,int24,int24,uint256,uint256,address,uint256,bool))","name":"migrate","description":"Migrates liquidity to v3 by burning v2 liquidity and minting a new position for v3. Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of the maximum amount of v3 liquidity that the v2 liquidity can get. For the special case of migrating to an out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range.","parameterDecorators":[{"name":"params","description":"The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata.","recommendedTypes":[],"parameters":[{"name":"pair","description":"","type":"address"},{"name":"liquidityToMigrate","description":"","type":"uint256"},{"name":"percentageToMigrate","description":"","type":"uint8"},{"name":"token0","description":"","type":"address"},{"name":"token1","description":"","type":"address"},{"name":"fee","description":"","type":"uint24"},{"name":"tickLower","description":"","type":"int24"},{"name":"tickUpper","description":"","type":"int24"},{"name":"amount0Min","description":"","type":"uint256"},{"name":"amount1Min","description":"","type":"uint256"},{"name":"recipient","description":"","type":"address"},{"name":"deadline","description":"","type":"uint256"},{"name":"refundAsETH","description":"","type":"bool"}]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"multicall(bytes[])","name":"multicall","description":"Call multiple functions in the current contract and return the data from all of them if they all succeed. The `msg.value` should not be trusted for any method callable from multicall.","parameterDecorators":[{"name":"data","description":"The encoded function data for each of the calls to make to this contract.","recommendedTypes":[]}],"returnDecorators":[{"name":"results","description":"The results from each of the calls passed in via data.","recommendedTypes":[],"solidityType":"bytes[]"}],"emittableEvents":[],"readOnly":false},{"signature":"nonfungiblePositionManager()","name":"nonfungiblePositionManager","description":"","parameterDecorators":[],"returnDecorators":[{"name":"param0","description":"","recommendedTypes":[],"solidityType":"address"}],"emittableEvents":[],"readOnly":true},{"signature":"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)","name":"selfPermit","description":"Permits this contract to spend a given token from `msg.sender`. The `owner` is always msg.sender and the `spender` is always address(this).","parameterDecorators":[{"name":"token","description":"The address of the token spent.","recommendedTypes":[]},{"name":"value","description":"The amount that can be spent of token.","recommendedTypes":[]},{"name":"deadline","description":"A timestamp, the current blocktime must be less than or equal to this timestamp.","recommendedTypes":[]},{"name":"v","description":"Must produce valid secp256k1 signature from the holder along with `r` and `s`.","recommendedTypes":[]},{"name":"r","description":"Must produce valid secp256k1 signature from the holder along with `v` and `s`.","recommendedTypes":[]},{"name":"s","description":"Must produce valid secp256k1 signature from the holder along with `r` and `v`.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)","name":"selfPermitAllowed","description":"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter. The `owner` is always msg.sender and the `spender` is always address(this).","parameterDecorators":[{"name":"token","description":"The address of the token spent.","recommendedTypes":[]},{"name":"nonce","description":"The current nonce of the owner.","recommendedTypes":[]},{"name":"expiry","description":"The timestamp at which the permit is no longer valid.","recommendedTypes":[]},{"name":"v","description":"Must produce valid secp256k1 signature from the holder along with `r` and `s`.","recommendedTypes":[]},{"name":"r","description":"Must produce valid secp256k1 signature from the holder along with `v` and `s`.","recommendedTypes":[]},{"name":"s","description":"Must produce valid secp256k1 signature from the holder along with `r` and `v`.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)","name":"selfPermitAllowedIfNecessary","description":"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter. The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.","parameterDecorators":[{"name":"token","description":"The address of the token spent.","recommendedTypes":[]},{"name":"nonce","description":"The current nonce of the owner.","recommendedTypes":[]},{"name":"expiry","description":"The timestamp at which the permit is no longer valid.","recommendedTypes":[]},{"name":"v","description":"Must produce valid secp256k1 signature from the holder along with `r` and `s`.","recommendedTypes":[]},{"name":"r","description":"Must produce valid secp256k1 signature from the holder along with `v` and `s`.","recommendedTypes":[]},{"name":"s","description":"Must produce valid secp256k1 signature from the holder along with `r` and `v`.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false},{"signature":"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)","name":"selfPermitIfNecessary","description":"Permits this contract to spend a given token from `msg.sender`. The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit.","parameterDecorators":[{"name":"token","description":"The address of the token spent.","recommendedTypes":[]},{"name":"value","description":"The amount that can be spent of token.","recommendedTypes":[]},{"name":"deadline","description":"A timestamp, the current blocktime must be less than or equal to this timestamp.","recommendedTypes":[]},{"name":"v","description":"Must produce valid secp256k1 signature from the holder along with `r` and `s`.","recommendedTypes":[]},{"name":"r","description":"Must produce valid secp256k1 signature from the holder along with `v` and `s`.","recommendedTypes":[]},{"name":"s","description":"Must produce valid secp256k1 signature from the holder along with `r` and `v`.","recommendedTypes":[]}],"returnDecorators":[],"emittableEvents":[],"readOnly":false}]}