{
  "schema": "../schema.json",
  "tags": [],
  "name": "Lands",
  "description": "",
  "eventDecorators": [
    {
      "signature": "Approval(address,address,string,uint256)",
      "name": "Approval",
      "description": "Emitted when a edition is created reserving the corresponding token IDs.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "spender",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "tokenId",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "amount",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "ApprovalForAll(address,address,bool)",
      "name": "ApprovalForAll",
      "description": "Emitted when a edition is created reserving the corresponding token IDs.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "operator",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "approved",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "Paused(address)",
      "name": "Paused",
      "description": "Emitted when a edition is created reserving the corresponding token IDs.",
      "parameterDecorators": [
        {
          "name": "editionId",
          "description": "ID of newly created edition.",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "PauserAdded(address)",
      "name": "PauserAdded",
      "description": "Emitted when a edition is created reserving the corresponding token IDs.",
      "parameterDecorators": [
        {
          "name": "editionId",
          "description": "ID of newly created edition.",
          "recommendedTypes": [],
          "indexed": true
        }
      ]
    },
    {
      "signature": "PauserRemoved(address)",
      "name": "PauserRemoved",
      "description": "Emitted when a edition is created reserving the corresponding token IDs.",
      "parameterDecorators": [
        {
          "name": "editionId",
          "description": "ID of newly created edition.",
          "recommendedTypes": [],
          "indexed": true
        }
      ]
    },
    {
      "signature": "Transfer(address,address,string,uint256)",
      "name": "Transfer",
      "description": "Emitted when a edition is created reserving the corresponding token IDs.",
      "parameterDecorators": [
        {
          "name": "from",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "to",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "tokenId",
          "description": "",
          "recommendedTypes": [],
          "indexed": true
        },
        {
          "name": "amount",
          "description": "",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    },
    {
      "signature": "Unpaused(address)",
      "name": "Unpaused",
      "description": "Emitted when a edition is created reserving the corresponding token IDs.",
      "parameterDecorators": [
        {
          "name": "editionId",
          "description": "ID of newly created edition.",
          "recommendedTypes": [],
          "indexed": false
        }
      ]
    }
  ],
  "functionDecorators": [
    {
      "signature": "addPauser(address)",
      "name": "addPauser",
      "description": "",
      "parameterDecorators": [
        {
          "name": "account",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "approve(address,address,string,uint256)",
      "name": "approve",
      "description": "Change or reaffirm the approved address for an NFT. Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "address of NFT owner.",
          "recommendedTypes": []
        },
        {
          "name": "spender",
          "description": "address of new NFT controller.",
          "recommendedTypes": []
        },
        {
          "name": "tokenId",
          "description": "The NFT to approve.",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "number of NFT to approve.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "balanceOf(address)",
      "name": "balanceOf",
      "description": "Count all NFTs assigned to an owner. NFTs assigned to the zero address are considered invalid, and this function throws for queries about the zero address.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "An address for whom to query the balance.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "The number of NFTs owned by `_owner`, possibly zero.",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getApproved(address,address,string)",
      "name": "getApproved",
      "description": "Get the approved amount of a single NFT. Throws if `tokenId` is not a valid NFT.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "address of owner of The NFT.",
          "recommendedTypes": []
        },
        {
          "name": "spender",
          "description": "address of controler of The NFT.",
          "recommendedTypes": []
        },
        {
          "name": "tokenId",
          "description": "The NFT id.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "The approved amount for this NFT.",
          "recommendedTypes": [],
          "solidityType": "uint256"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getTokenTimestamp(address,string)",
      "name": "getTokenTimestamp",
      "description": "get token timestamp. throw if token is not valid.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "tokenId",
          "description": "id of the token.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "token timestamp.",
          "recommendedTypes": [],
          "solidityType": "uint64"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "getTokensOfOwner(address)",
      "name": "getTokensOfOwner",
      "description": "get list of token ids of an owner. throw if 'owner' is zero address.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "address of owner.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "list of token ids of owner.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "id",
              "description": "",
              "recommendedTypes": [],
              "solidityType": "string"
            },
            {
              "name": "balance",
              "description": "",
              "recommendedTypes": [],
              "solidityType": "uint256"
            },
            {
              "name": "timestamp",
              "description": "",
              "recommendedTypes": [],
              "solidityType": "uint64"
            }
          ],
          "solidityType": "tuple[]"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "isApprovedForAll(address,address)",
      "name": "isApprovedForAll",
      "description": "Query if an address is an authorized operator for another address.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "The address that owns the NFTs.",
          "recommendedTypes": []
        },
        {
          "name": "operator",
          "description": "The address that acts on behalf of the owner.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "True if `operator` is an approved operator for `owner`, false otherwise.",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "isOwnerOf(address,string)",
      "name": "isOwnerOf",
      "description": "check the owner of an NFT. Throw if tokenId is not valid.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "address need to check.",
          "recommendedTypes": []
        },
        {
          "name": "tokenId",
          "description": "The identifier for an NFT.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "true if is owner, false if not.",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "isPauser(address)",
      "name": "isPauser",
      "description": "",
      "parameterDecorators": [
        {
          "name": "account",
          "description": "",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "issueToken(address,string,uint256)",
      "name": "issueToken",
      "description": "Mints more tokens, can only be called by contract creator and all newly minted tokens will belong to creator. check if token id is duplicated, or null or burned. Throw if msg.sender is not creator.",
      "parameterDecorators": [
        {
          "name": "to",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "tokenId",
          "description": "array of extra tokens to mint.",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "number of token.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "name()",
      "name": "name",
      "description": "A descriptive name for a collection of NFTs in this contract.",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "__name",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "string"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "pause()",
      "name": "pause",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "paused()",
      "name": "paused",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "param0",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "renouncePauser()",
      "name": "renouncePauser",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "safeTransferFrom(address,address,string,uint256,bytes)",
      "name": "safeTransferFrom",
      "description": "Transfers number of an NFT from one address to another address. When transfer is complete, this function checks if `to` is a smart contract (code size > 0). If so, it calls `onERC721Received` on `to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,address,string,uint256,bytes)\"))`.",
      "parameterDecorators": [
        {
          "name": "from",
          "description": "The current owner of the NFT.",
          "recommendedTypes": []
        },
        {
          "name": "to",
          "description": "The new owner.",
          "recommendedTypes": []
        },
        {
          "name": "tokenId",
          "description": "The NFT to transfer.",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "The amount of NFT to transfer.",
          "recommendedTypes": []
        },
        {
          "name": "data",
          "description": "Additional data with no specified format, sent in call to `to`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "safeTransferFrom(address,address,string,uint256)",
      "name": "safeTransferFrom",
      "description": "Transfers a number of an NFT from one address to another address. This works identically to the other function with an extra data parameter, except this function just sets data to \"\".",
      "parameterDecorators": [
        {
          "name": "from",
          "description": "The current owner of the NFT.",
          "recommendedTypes": []
        },
        {
          "name": "to",
          "description": "The new owner.",
          "recommendedTypes": []
        },
        {
          "name": "tokenId",
          "description": "The NFT to transfer.",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "The amount of NFT to transfer.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "setApprovalForAll(address,bool)",
      "name": "setApprovalForAll",
      "description": "Enable or disable approval for a third party (\"operator\") to manage all of `msg.sender`'s assets. Emits the ApprovalForAll event. The contract MUST allow multiple operators per owner.",
      "parameterDecorators": [
        {
          "name": "operator",
          "description": "Address to add to the set of authorized operators.",
          "recommendedTypes": []
        },
        {
          "name": "approved",
          "description": "True if the operator is approved, false to revoke approval.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "supportsInterface(bytes4)",
      "name": "supportsInterface",
      "description": "Query if a contract implements an interface. Interface identification is specified in ERC-165. This function uses less than 30,000 gas.",
      "parameterDecorators": [
        {
          "name": "interfaceID",
          "description": "The interface identifier, as specified in ERC-165.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "`true` if the contract implements `interfaceID` and `interfaceID` is not 0xffffffff, `false` otherwise.",
          "recommendedTypes": [],
          "solidityType": "bool"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "symbol()",
      "name": "symbol",
      "description": "An abbreviated name for NFTs in this contract.",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "__symbol",
          "description": "",
          "recommendedTypes": [],
          "solidityType": "string"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "tokenByIndex(uint256)",
      "name": "tokenByIndex",
      "description": "Enumerate valid NFTs. Throws if `index` >= `totalSupply()`.",
      "parameterDecorators": [
        {
          "name": "index",
          "description": "A counter less than `totalSupply()`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "The token identifier for the `index`th NFT, (sort order not specified).",
          "recommendedTypes": [],
          "solidityType": "string"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "tokenOfOwnerByIndex(address,uint256)",
      "name": "tokenOfOwnerByIndex",
      "description": "Enumerate NFTs assigned to an owner. Throws if `index` >= `balanceOf(owner)` or if `owner` is the zero address, representing invalid NFTs.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "An address where we are interested in NFTs owned by them.",
          "recommendedTypes": []
        },
        {
          "name": "index",
          "description": "A counter less than `balanceOf(owner)`.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "The token identifier for the `index`th NFT assigned to `owner`, (sort order not specified).",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "id",
              "description": "",
              "recommendedTypes": [],
              "solidityType": "string"
            },
            {
              "name": "balance",
              "description": "",
              "recommendedTypes": [],
              "solidityType": "uint256"
            },
            {
              "name": "timestamp",
              "description": "",
              "recommendedTypes": [],
              "solidityType": "uint64"
            }
          ],
          "solidityType": "tuple"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "totalSupply()",
      "name": "totalSupply",
      "description": "Count NFTs tracked by this contract.",
      "parameterDecorators": [],
      "returnDecorators": [
        {
          "name": "_0",
          "description": "A count of valid NFTs tracked by this contract, where each one of them has an assigned and queryable owner not equal to the zero address.",
          "recommendedTypes": [],
          "parameters": [
            {
              "name": "totalIdSupplies",
              "description": "",
              "recommendedTypes": [],
              "solidityType": "uint256"
            },
            {
              "name": "totalTokenSupples",
              "description": "",
              "recommendedTypes": [],
              "solidityType": "uint256"
            }
          ],
          "solidityType": "tuple"
        }
      ],
      "emittableEvents": [],
      "readOnly": true
    },
    {
      "signature": "transferFrom(address,address,string,uint256)",
      "name": "transferFrom",
      "description": "Transfer a number of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT `to` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST. Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `from` is not the current owner. Throws if `to` is the zero address. Throws if `tokenId` is not a valid NFT. Throws if the NFT balance is less than `amount`.",
      "parameterDecorators": [
        {
          "name": "from",
          "description": "The current owner of the NFT.",
          "recommendedTypes": []
        },
        {
          "name": "to",
          "description": "The new owner.",
          "recommendedTypes": []
        },
        {
          "name": "tokenId",
          "description": "The NFT to transfer.",
          "recommendedTypes": []
        },
        {
          "name": "amount",
          "description": "The amount of NFT to transfer.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "unpause()",
      "name": "unpause",
      "description": "",
      "parameterDecorators": [],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    },
    {
      "signature": "updateTokenTimestamp(address,string,uint64)",
      "name": "updateTokenTimestamp",
      "description": "change the token timestamp. only creator or operator of creator can change it. throw unless token id is valid.",
      "parameterDecorators": [
        {
          "name": "owner",
          "description": "",
          "recommendedTypes": []
        },
        {
          "name": "tokenId",
          "description": "id of token.",
          "recommendedTypes": []
        },
        {
          "name": "newTimestamp",
          "description": "new value of token timestamp.",
          "recommendedTypes": []
        }
      ],
      "returnDecorators": [],
      "emittableEvents": [],
      "readOnly": false
    }
  ]
}